/* tslint:disable */
/* eslint-disable */
/**
 * YNAB API Endpoints
 * Our API uses a REST based design, leverages the JSON data format, and relies upon HTTPS for transport. We respond with meaningful HTTP response codes and if an error occurs, we include error details in the response body.  API Documentation is at https://api.youneedabudget.com
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface IAccount
 */
export interface IAccount {
    /**
     * 
     * @type {string}
     * @memberof IAccount
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof IAccount
     */
    'name': string;
    /**
     * The type of account. Note: payPal, merchantAccount, investmentAccount, and mortgage types have been deprecated and will be removed in the future.
     * @type {string}
     * @memberof IAccount
     */
    'type': IAccountTypeEnum;
    /**
     * Whether this account is on budget or not
     * @type {boolean}
     * @memberof IAccount
     */
    'on_budget': boolean;
    /**
     * Whether this account is closed or not
     * @type {boolean}
     * @memberof IAccount
     */
    'closed': boolean;
    /**
     * 
     * @type {string}
     * @memberof IAccount
     */
    'note'?: string;
    /**
     * The current balance of the account in milliunits format
     * @type {number}
     * @memberof IAccount
     */
    'balance': number;
    /**
     * The current cleared balance of the account in milliunits format
     * @type {number}
     * @memberof IAccount
     */
    'cleared_balance': number;
    /**
     * The current uncleared balance of the account in milliunits format
     * @type {number}
     * @memberof IAccount
     */
    'uncleared_balance': number;
    /**
     * The payee id which should be used when transferring to this account
     * @type {string}
     * @memberof IAccount
     */
    'transfer_payee_id': string;
    /**
     * Whether or not the account is linked to a financial institution for automatic transaction import.
     * @type {boolean}
     * @memberof IAccount
     */
    'direct_import_linked'?: boolean;
    /**
     * If an account linked to a financial institution (direct_import_linked=true) and the linked connection is not in a healthy state, this will be true.
     * @type {boolean}
     * @memberof IAccount
     */
    'direct_import_in_error'?: boolean;
    /**
     * Whether or not the account has been deleted.  Deleted accounts will only be included in delta requests.
     * @type {boolean}
     * @memberof IAccount
     */
    'deleted': boolean;
}

export const IAccountTypeEnum = {
    Checking: 'checking',
    Savings: 'savings',
    Cash: 'cash',
    CreditCard: 'creditCard',
    LineOfCredit: 'lineOfCredit',
    OtherAsset: 'otherAsset',
    OtherLiability: 'otherLiability',
    PayPal: 'payPal',
    MerchantAccount: 'merchantAccount',
    InvestmentAccount: 'investmentAccount',
    Mortgage: 'mortgage'
} as const;

export type IAccountTypeEnum = typeof IAccountTypeEnum[keyof typeof IAccountTypeEnum];

/**
 * 
 * @export
 * @interface IAccountResponse
 */
export interface IAccountResponse {
    /**
     * 
     * @type {IAccountResponseData}
     * @memberof IAccountResponse
     */
    'data': IAccountResponseData;
}
/**
 * 
 * @export
 * @interface IAccountResponseData
 */
export interface IAccountResponseData {
    /**
     * 
     * @type {IAccount}
     * @memberof IAccountResponseData
     */
    'account': IAccount;
}
/**
 * 
 * @export
 * @interface IAccountsResponse
 */
export interface IAccountsResponse {
    /**
     * 
     * @type {IAccountsResponseData}
     * @memberof IAccountsResponse
     */
    'data': IAccountsResponseData;
}
/**
 * 
 * @export
 * @interface IAccountsResponseData
 */
export interface IAccountsResponseData {
    /**
     * 
     * @type {Array<IAccount>}
     * @memberof IAccountsResponseData
     */
    'accounts': Array<IAccount>;
    /**
     * The knowledge of the server
     * @type {number}
     * @memberof IAccountsResponseData
     */
    'server_knowledge': number;
}
/**
 * 
 * @export
 * @interface IBudgetDetail
 */
export interface IBudgetDetail {
    /**
     * 
     * @type {string}
     * @memberof IBudgetDetail
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof IBudgetDetail
     */
    'name': string;
    /**
     * The last time any changes were made to the budget from either a web or mobile client
     * @type {string}
     * @memberof IBudgetDetail
     */
    'last_modified_on'?: string;
    /**
     * The earliest budget month
     * @type {string}
     * @memberof IBudgetDetail
     */
    'first_month'?: string;
    /**
     * The latest budget month
     * @type {string}
     * @memberof IBudgetDetail
     */
    'last_month'?: string;
    /**
     * 
     * @type {IDateFormat}
     * @memberof IBudgetDetail
     */
    'date_format'?: IDateFormat;
    /**
     * 
     * @type {ICurrencyFormat}
     * @memberof IBudgetDetail
     */
    'currency_format'?: ICurrencyFormat;
    /**
     * 
     * @type {Array<IAccount>}
     * @memberof IBudgetDetail
     */
    'accounts'?: Array<IAccount>;
    /**
     * 
     * @type {Array<IPayee>}
     * @memberof IBudgetDetail
     */
    'payees'?: Array<IPayee>;
    /**
     * 
     * @type {Array<IPayeeLocation>}
     * @memberof IBudgetDetail
     */
    'payee_locations'?: Array<IPayeeLocation>;
    /**
     * 
     * @type {Array<ICategoryGroup>}
     * @memberof IBudgetDetail
     */
    'category_groups'?: Array<ICategoryGroup>;
    /**
     * 
     * @type {Array<ICategory>}
     * @memberof IBudgetDetail
     */
    'categories'?: Array<ICategory>;
    /**
     * 
     * @type {Array<IMonthDetail>}
     * @memberof IBudgetDetail
     */
    'months'?: Array<IMonthDetail>;
    /**
     * 
     * @type {Array<ITransactionSummary>}
     * @memberof IBudgetDetail
     */
    'transactions'?: Array<ITransactionSummary>;
    /**
     * 
     * @type {Array<ISubTransaction>}
     * @memberof IBudgetDetail
     */
    'subtransactions'?: Array<ISubTransaction>;
    /**
     * 
     * @type {Array<IScheduledTransactionSummary>}
     * @memberof IBudgetDetail
     */
    'scheduled_transactions'?: Array<IScheduledTransactionSummary>;
    /**
     * 
     * @type {Array<IScheduledSubTransaction>}
     * @memberof IBudgetDetail
     */
    'scheduled_subtransactions'?: Array<IScheduledSubTransaction>;
}
/**
 * 
 * @export
 * @interface IBudgetDetailAllOf
 */
export interface IBudgetDetailAllOf {
    /**
     * 
     * @type {Array<IAccount>}
     * @memberof IBudgetDetailAllOf
     */
    'accounts'?: Array<IAccount>;
    /**
     * 
     * @type {Array<IPayee>}
     * @memberof IBudgetDetailAllOf
     */
    'payees'?: Array<IPayee>;
    /**
     * 
     * @type {Array<IPayeeLocation>}
     * @memberof IBudgetDetailAllOf
     */
    'payee_locations'?: Array<IPayeeLocation>;
    /**
     * 
     * @type {Array<ICategoryGroup>}
     * @memberof IBudgetDetailAllOf
     */
    'category_groups'?: Array<ICategoryGroup>;
    /**
     * 
     * @type {Array<ICategory>}
     * @memberof IBudgetDetailAllOf
     */
    'categories'?: Array<ICategory>;
    /**
     * 
     * @type {Array<IMonthDetail>}
     * @memberof IBudgetDetailAllOf
     */
    'months'?: Array<IMonthDetail>;
    /**
     * 
     * @type {Array<ITransactionSummary>}
     * @memberof IBudgetDetailAllOf
     */
    'transactions'?: Array<ITransactionSummary>;
    /**
     * 
     * @type {Array<ISubTransaction>}
     * @memberof IBudgetDetailAllOf
     */
    'subtransactions'?: Array<ISubTransaction>;
    /**
     * 
     * @type {Array<IScheduledTransactionSummary>}
     * @memberof IBudgetDetailAllOf
     */
    'scheduled_transactions'?: Array<IScheduledTransactionSummary>;
    /**
     * 
     * @type {Array<IScheduledSubTransaction>}
     * @memberof IBudgetDetailAllOf
     */
    'scheduled_subtransactions'?: Array<IScheduledSubTransaction>;
}
/**
 * 
 * @export
 * @interface IBudgetDetailResponse
 */
export interface IBudgetDetailResponse {
    /**
     * 
     * @type {IBudgetDetailResponseData}
     * @memberof IBudgetDetailResponse
     */
    'data': IBudgetDetailResponseData;
}
/**
 * 
 * @export
 * @interface IBudgetDetailResponseData
 */
export interface IBudgetDetailResponseData {
    /**
     * 
     * @type {IBudgetDetail}
     * @memberof IBudgetDetailResponseData
     */
    'budget': IBudgetDetail;
    /**
     * The knowledge of the server
     * @type {number}
     * @memberof IBudgetDetailResponseData
     */
    'server_knowledge': number;
}
/**
 * 
 * @export
 * @interface IBudgetSettings
 */
export interface IBudgetSettings {
    /**
     * 
     * @type {IDateFormat}
     * @memberof IBudgetSettings
     */
    'date_format': IDateFormat;
    /**
     * 
     * @type {ICurrencyFormat}
     * @memberof IBudgetSettings
     */
    'currency_format': ICurrencyFormat;
}
/**
 * 
 * @export
 * @interface IBudgetSettingsResponse
 */
export interface IBudgetSettingsResponse {
    /**
     * 
     * @type {IBudgetSettingsResponseData}
     * @memberof IBudgetSettingsResponse
     */
    'data': IBudgetSettingsResponseData;
}
/**
 * 
 * @export
 * @interface IBudgetSettingsResponseData
 */
export interface IBudgetSettingsResponseData {
    /**
     * 
     * @type {IBudgetSettings}
     * @memberof IBudgetSettingsResponseData
     */
    'settings': IBudgetSettings;
}
/**
 * 
 * @export
 * @interface IBudgetSummary
 */
export interface IBudgetSummary {
    /**
     * 
     * @type {string}
     * @memberof IBudgetSummary
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof IBudgetSummary
     */
    'name': string;
    /**
     * The last time any changes were made to the budget from either a web or mobile client
     * @type {string}
     * @memberof IBudgetSummary
     */
    'last_modified_on'?: string;
    /**
     * The earliest budget month
     * @type {string}
     * @memberof IBudgetSummary
     */
    'first_month'?: string;
    /**
     * The latest budget month
     * @type {string}
     * @memberof IBudgetSummary
     */
    'last_month'?: string;
    /**
     * 
     * @type {IDateFormat}
     * @memberof IBudgetSummary
     */
    'date_format'?: IDateFormat;
    /**
     * 
     * @type {ICurrencyFormat}
     * @memberof IBudgetSummary
     */
    'currency_format'?: ICurrencyFormat;
    /**
     * The budget accounts (only included if `include_accounts=true` specified as query parameter)
     * @type {Array<IAccount>}
     * @memberof IBudgetSummary
     */
    'accounts'?: Array<IAccount>;
}
/**
 * 
 * @export
 * @interface IBudgetSummaryResponse
 */
export interface IBudgetSummaryResponse {
    /**
     * 
     * @type {IBudgetSummaryResponseData}
     * @memberof IBudgetSummaryResponse
     */
    'data': IBudgetSummaryResponseData;
}
/**
 * 
 * @export
 * @interface IBudgetSummaryResponseData
 */
export interface IBudgetSummaryResponseData {
    /**
     * 
     * @type {Array<IBudgetSummary>}
     * @memberof IBudgetSummaryResponseData
     */
    'budgets': Array<IBudgetSummary>;
    /**
     * 
     * @type {IBudgetSummary}
     * @memberof IBudgetSummaryResponseData
     */
    'default_budget'?: IBudgetSummary;
}
/**
 * 
 * @export
 * @interface IBulkResponse
 */
export interface IBulkResponse {
    /**
     * 
     * @type {IBulkResponseData}
     * @memberof IBulkResponse
     */
    'data': IBulkResponseData;
}
/**
 * 
 * @export
 * @interface IBulkResponseData
 */
export interface IBulkResponseData {
    /**
     * 
     * @type {IBulkResponseDataBulk}
     * @memberof IBulkResponseData
     */
    'bulk': IBulkResponseDataBulk;
}
/**
 * 
 * @export
 * @interface IBulkResponseDataBulk
 */
export interface IBulkResponseDataBulk {
    /**
     * The list of Transaction ids that were created.
     * @type {Array<string>}
     * @memberof IBulkResponseDataBulk
     */
    'transaction_ids': Array<string>;
    /**
     * If any Transactions were not created because they had an `import_id` matching a transaction already on the same account, the specified import_id(s) will be included in this list.
     * @type {Array<string>}
     * @memberof IBulkResponseDataBulk
     */
    'duplicate_import_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface IBulkTransactions
 */
export interface IBulkTransactions {
    /**
     * 
     * @type {Array<ISaveTransaction>}
     * @memberof IBulkTransactions
     */
    'transactions': Array<ISaveTransaction>;
}
/**
 * 
 * @export
 * @interface ICategoriesResponse
 */
export interface ICategoriesResponse {
    /**
     * 
     * @type {ICategoriesResponseData}
     * @memberof ICategoriesResponse
     */
    'data': ICategoriesResponseData;
}
/**
 * 
 * @export
 * @interface ICategoriesResponseData
 */
export interface ICategoriesResponseData {
    /**
     * 
     * @type {Array<ICategoryGroupWithCategories>}
     * @memberof ICategoriesResponseData
     */
    'category_groups': Array<ICategoryGroupWithCategories>;
    /**
     * The knowledge of the server
     * @type {number}
     * @memberof ICategoriesResponseData
     */
    'server_knowledge': number;
}
/**
 * 
 * @export
 * @interface ICategory
 */
export interface ICategory {
    /**
     * 
     * @type {string}
     * @memberof ICategory
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ICategory
     */
    'category_group_id': string;
    /**
     * 
     * @type {string}
     * @memberof ICategory
     */
    'name': string;
    /**
     * Whether or not the category is hidden
     * @type {boolean}
     * @memberof ICategory
     */
    'hidden': boolean;
    /**
     * If category is hidden this is the id of the category group it originally belonged to before it was hidden.
     * @type {string}
     * @memberof ICategory
     */
    'original_category_group_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ICategory
     */
    'note'?: string;
    /**
     * Budgeted amount in milliunits format
     * @type {number}
     * @memberof ICategory
     */
    'budgeted': number;
    /**
     * Activity amount in milliunits format
     * @type {number}
     * @memberof ICategory
     */
    'activity': number;
    /**
     * Balance in milliunits format
     * @type {number}
     * @memberof ICategory
     */
    'balance': number;
    /**
     * The type of goal, if the category has a goal (TB=\'Target Category Balance\', TBD=\'Target Category Balance by Date\', MF=\'Monthly Funding\', NEED=\'Plan Your Spending\')
     * @type {string}
     * @memberof ICategory
     */
    'goal_type'?: ICategoryGoalTypeEnum;
    /**
     * The month a goal was created
     * @type {string}
     * @memberof ICategory
     */
    'goal_creation_month'?: string;
    /**
     * The goal target amount in milliunits
     * @type {number}
     * @memberof ICategory
     */
    'goal_target'?: number;
    /**
     * The original target month for the goal to be completed.  Only some goal types specify this date.
     * @type {string}
     * @memberof ICategory
     */
    'goal_target_month'?: string;
    /**
     * The percentage completion of the goal
     * @type {number}
     * @memberof ICategory
     */
    'goal_percentage_complete'?: number;
    /**
     * The number of months, including the current month, left in the current goal period.
     * @type {number}
     * @memberof ICategory
     */
    'goal_months_to_budget'?: number;
    /**
     * The amount of funding still needed in the current month to stay on track towards completing the goal within the current goal period.  This amount will generally correspond to the \'Underfunded\' amount in the web and mobile clients except when viewing a category with a Needed for Spending Goal in a future month.  The web and mobile clients will ignore any funding from a prior goal period when viewing category with a Needed for Spending Goal in a future month.
     * @type {number}
     * @memberof ICategory
     */
    'goal_under_funded'?: number;
    /**
     * The total amount funded towards the goal within the current goal period.
     * @type {number}
     * @memberof ICategory
     */
    'goal_overall_funded'?: number;
    /**
     * The amount of funding still needed to complete the goal within the current goal period.
     * @type {number}
     * @memberof ICategory
     */
    'goal_overall_left'?: number;
    /**
     * Whether or not the category has been deleted.  Deleted categories will only be included in delta requests.
     * @type {boolean}
     * @memberof ICategory
     */
    'deleted': boolean;
}

export const ICategoryGoalTypeEnum = {
    Tb: 'TB',
    Tbd: 'TBD',
    Mf: 'MF',
    Need: 'NEED',
    Debt: 'DEBT'
} as const;

export type ICategoryGoalTypeEnum = typeof ICategoryGoalTypeEnum[keyof typeof ICategoryGoalTypeEnum];

/**
 * 
 * @export
 * @interface ICategoryGroup
 */
export interface ICategoryGroup {
    /**
     * 
     * @type {string}
     * @memberof ICategoryGroup
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ICategoryGroup
     */
    'name': string;
    /**
     * Whether or not the category group is hidden
     * @type {boolean}
     * @memberof ICategoryGroup
     */
    'hidden': boolean;
    /**
     * Whether or not the category group has been deleted.  Deleted category groups will only be included in delta requests.
     * @type {boolean}
     * @memberof ICategoryGroup
     */
    'deleted': boolean;
}
/**
 * 
 * @export
 * @interface ICategoryGroupWithCategories
 */
export interface ICategoryGroupWithCategories {
    /**
     * 
     * @type {string}
     * @memberof ICategoryGroupWithCategories
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ICategoryGroupWithCategories
     */
    'name': string;
    /**
     * Whether or not the category group is hidden
     * @type {boolean}
     * @memberof ICategoryGroupWithCategories
     */
    'hidden': boolean;
    /**
     * Whether or not the category group has been deleted.  Deleted category groups will only be included in delta requests.
     * @type {boolean}
     * @memberof ICategoryGroupWithCategories
     */
    'deleted': boolean;
    /**
     * Category group categories.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
     * @type {Array<ICategory>}
     * @memberof ICategoryGroupWithCategories
     */
    'categories': Array<ICategory>;
}
/**
 * 
 * @export
 * @interface ICategoryGroupWithCategoriesAllOf
 */
export interface ICategoryGroupWithCategoriesAllOf {
    /**
     * Category group categories.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
     * @type {Array<ICategory>}
     * @memberof ICategoryGroupWithCategoriesAllOf
     */
    'categories': Array<ICategory>;
}
/**
 * 
 * @export
 * @interface ICategoryResponse
 */
export interface ICategoryResponse {
    /**
     * 
     * @type {ICategoryResponseData}
     * @memberof ICategoryResponse
     */
    'data': ICategoryResponseData;
}
/**
 * 
 * @export
 * @interface ICategoryResponseData
 */
export interface ICategoryResponseData {
    /**
     * 
     * @type {ICategory}
     * @memberof ICategoryResponseData
     */
    'category': ICategory;
}
/**
 * The currency format setting for the budget.  In some cases the format will not be available and will be specified as null.
 * @export
 * @interface ICurrencyFormat
 */
export interface ICurrencyFormat {
    /**
     * 
     * @type {string}
     * @memberof ICurrencyFormat
     */
    'iso_code': string;
    /**
     * 
     * @type {string}
     * @memberof ICurrencyFormat
     */
    'example_format': string;
    /**
     * 
     * @type {number}
     * @memberof ICurrencyFormat
     */
    'decimal_digits': number;
    /**
     * 
     * @type {string}
     * @memberof ICurrencyFormat
     */
    'decimal_separator': string;
    /**
     * 
     * @type {boolean}
     * @memberof ICurrencyFormat
     */
    'symbol_first': boolean;
    /**
     * 
     * @type {string}
     * @memberof ICurrencyFormat
     */
    'group_separator': string;
    /**
     * 
     * @type {string}
     * @memberof ICurrencyFormat
     */
    'currency_symbol': string;
    /**
     * 
     * @type {boolean}
     * @memberof ICurrencyFormat
     */
    'display_symbol': boolean;
}
/**
 * The date format setting for the budget.  In some cases the format will not be available and will be specified as null.
 * @export
 * @interface IDateFormat
 */
export interface IDateFormat {
    /**
     * 
     * @type {string}
     * @memberof IDateFormat
     */
    'format': string;
}
/**
 * 
 * @export
 * @interface IErrorDetail
 */
export interface IErrorDetail {
    /**
     * 
     * @type {string}
     * @memberof IErrorDetail
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof IErrorDetail
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof IErrorDetail
     */
    'detail': string;
}
/**
 * 
 * @export
 * @interface IErrorResponse
 */
export interface IErrorResponse {
    /**
     * 
     * @type {IErrorDetail}
     * @memberof IErrorResponse
     */
    'error': IErrorDetail;
}
/**
 * 
 * @export
 * @interface IHybridTransaction
 */
export interface IHybridTransaction {
    /**
     * 
     * @type {string}
     * @memberof IHybridTransaction
     */
    'id': string;
    /**
     * The transaction date in ISO format (e.g. 2016-12-01)
     * @type {string}
     * @memberof IHybridTransaction
     */
    'date': string;
    /**
     * The transaction amount in milliunits format
     * @type {number}
     * @memberof IHybridTransaction
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof IHybridTransaction
     */
    'memo'?: string;
    /**
     * The cleared status of the transaction
     * @type {string}
     * @memberof IHybridTransaction
     */
    'cleared': IHybridTransactionClearedEnum;
    /**
     * Whether or not the transaction is approved
     * @type {boolean}
     * @memberof IHybridTransaction
     */
    'approved': boolean;
    /**
     * The transaction flag
     * @type {string}
     * @memberof IHybridTransaction
     */
    'flag_color'?: IHybridTransactionFlagColorEnum;
    /**
     * 
     * @type {string}
     * @memberof IHybridTransaction
     */
    'account_id': string;
    /**
     * 
     * @type {string}
     * @memberof IHybridTransaction
     */
    'payee_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IHybridTransaction
     */
    'category_id'?: string;
    /**
     * If a transfer transaction, the account to which it transfers
     * @type {string}
     * @memberof IHybridTransaction
     */
    'transfer_account_id'?: string;
    /**
     * If a transfer transaction, the id of transaction on the other side of the transfer
     * @type {string}
     * @memberof IHybridTransaction
     */
    'transfer_transaction_id'?: string;
    /**
     * If transaction is matched, the id of the matched transaction
     * @type {string}
     * @memberof IHybridTransaction
     */
    'matched_transaction_id'?: string;
    /**
     * If the Transaction was imported, this field is a unique (by account) import identifier.  If this transaction was imported through File Based Import or Direct Import and not through the API, the import_id will have the format: \'YNAB:[milliunit_amount]:[iso_date]:[occurrence]\'.  For example, a transaction dated 2015-12-30 in the amount of -$294.23 USD would have an import_id of \'YNAB:-294230:2015-12-30:1\'.  If a second transaction on the same account was imported and had the same date and same amount, its import_id would be \'YNAB:-294230:2015-12-30:2\'.
     * @type {string}
     * @memberof IHybridTransaction
     */
    'import_id'?: string;
    /**
     * Whether or not the transaction has been deleted.  Deleted transactions will only be included in delta requests.
     * @type {boolean}
     * @memberof IHybridTransaction
     */
    'deleted': boolean;
    /**
     * Whether the hybrid transaction represents a regular transaction or a subtransaction
     * @type {string}
     * @memberof IHybridTransaction
     */
    'type': IHybridTransactionTypeEnum;
    /**
     * For subtransaction types, this is the id of the parent transaction.  For transaction types, this id will be always be null.
     * @type {string}
     * @memberof IHybridTransaction
     */
    'parent_transaction_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IHybridTransaction
     */
    'account_name': string;
    /**
     * 
     * @type {string}
     * @memberof IHybridTransaction
     */
    'payee_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof IHybridTransaction
     */
    'category_name'?: string;
}

export const IHybridTransactionClearedEnum = {
    Cleared: 'cleared',
    Uncleared: 'uncleared',
    Reconciled: 'reconciled'
} as const;

export type IHybridTransactionClearedEnum = typeof IHybridTransactionClearedEnum[keyof typeof IHybridTransactionClearedEnum];
export const IHybridTransactionFlagColorEnum = {
    Red: 'red',
    Orange: 'orange',
    Yellow: 'yellow',
    Green: 'green',
    Blue: 'blue',
    Purple: 'purple'
} as const;

export type IHybridTransactionFlagColorEnum = typeof IHybridTransactionFlagColorEnum[keyof typeof IHybridTransactionFlagColorEnum];
export const IHybridTransactionTypeEnum = {
    Transaction: 'transaction',
    Subtransaction: 'subtransaction'
} as const;

export type IHybridTransactionTypeEnum = typeof IHybridTransactionTypeEnum[keyof typeof IHybridTransactionTypeEnum];

/**
 * 
 * @export
 * @interface IHybridTransactionAllOf
 */
export interface IHybridTransactionAllOf {
    /**
     * Whether the hybrid transaction represents a regular transaction or a subtransaction
     * @type {string}
     * @memberof IHybridTransactionAllOf
     */
    'type': IHybridTransactionAllOfTypeEnum;
    /**
     * For subtransaction types, this is the id of the parent transaction.  For transaction types, this id will be always be null.
     * @type {string}
     * @memberof IHybridTransactionAllOf
     */
    'parent_transaction_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IHybridTransactionAllOf
     */
    'account_name': string;
    /**
     * 
     * @type {string}
     * @memberof IHybridTransactionAllOf
     */
    'payee_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof IHybridTransactionAllOf
     */
    'category_name'?: string;
}

export const IHybridTransactionAllOfTypeEnum = {
    Transaction: 'transaction',
    Subtransaction: 'subtransaction'
} as const;

export type IHybridTransactionAllOfTypeEnum = typeof IHybridTransactionAllOfTypeEnum[keyof typeof IHybridTransactionAllOfTypeEnum];

/**
 * 
 * @export
 * @interface IHybridTransactionsResponse
 */
export interface IHybridTransactionsResponse {
    /**
     * 
     * @type {IHybridTransactionsResponseData}
     * @memberof IHybridTransactionsResponse
     */
    'data': IHybridTransactionsResponseData;
}
/**
 * 
 * @export
 * @interface IHybridTransactionsResponseData
 */
export interface IHybridTransactionsResponseData {
    /**
     * 
     * @type {Array<IHybridTransaction>}
     * @memberof IHybridTransactionsResponseData
     */
    'transactions': Array<IHybridTransaction>;
}
/**
 * 
 * @export
 * @interface IMonthDetail
 */
export interface IMonthDetail {
    /**
     * 
     * @type {string}
     * @memberof IMonthDetail
     */
    'month': string;
    /**
     * 
     * @type {string}
     * @memberof IMonthDetail
     */
    'note'?: string;
    /**
     * The total amount of transactions categorized to \'Inflow: Ready to Assign\' in the month
     * @type {number}
     * @memberof IMonthDetail
     */
    'income': number;
    /**
     * The total amount budgeted in the month
     * @type {number}
     * @memberof IMonthDetail
     */
    'budgeted': number;
    /**
     * The total amount of transactions in the month, excluding those categorized to \'Inflow: Ready to Assign\'
     * @type {number}
     * @memberof IMonthDetail
     */
    'activity': number;
    /**
     * The available amount for \'Ready to Assign\'
     * @type {number}
     * @memberof IMonthDetail
     */
    'to_be_budgeted': number;
    /**
     * The Age of Money as of the month
     * @type {number}
     * @memberof IMonthDetail
     */
    'age_of_money'?: number;
    /**
     * Whether or not the month has been deleted.  Deleted months will only be included in delta requests.
     * @type {boolean}
     * @memberof IMonthDetail
     */
    'deleted': boolean;
    /**
     * The budget month categories.  Amounts (budgeted, activity, balance, etc.) are specific to the {month} parameter specified.
     * @type {Array<ICategory>}
     * @memberof IMonthDetail
     */
    'categories': Array<ICategory>;
}
/**
 * 
 * @export
 * @interface IMonthDetailAllOf
 */
export interface IMonthDetailAllOf {
    /**
     * The budget month categories.  Amounts (budgeted, activity, balance, etc.) are specific to the {month} parameter specified.
     * @type {Array<ICategory>}
     * @memberof IMonthDetailAllOf
     */
    'categories': Array<ICategory>;
}
/**
 * 
 * @export
 * @interface IMonthDetailResponse
 */
export interface IMonthDetailResponse {
    /**
     * 
     * @type {IMonthDetailResponseData}
     * @memberof IMonthDetailResponse
     */
    'data': IMonthDetailResponseData;
}
/**
 * 
 * @export
 * @interface IMonthDetailResponseData
 */
export interface IMonthDetailResponseData {
    /**
     * 
     * @type {IMonthDetail}
     * @memberof IMonthDetailResponseData
     */
    'month': IMonthDetail;
}
/**
 * 
 * @export
 * @interface IMonthSummariesResponse
 */
export interface IMonthSummariesResponse {
    /**
     * 
     * @type {IMonthSummariesResponseData}
     * @memberof IMonthSummariesResponse
     */
    'data': IMonthSummariesResponseData;
}
/**
 * 
 * @export
 * @interface IMonthSummariesResponseData
 */
export interface IMonthSummariesResponseData {
    /**
     * 
     * @type {Array<IMonthSummary>}
     * @memberof IMonthSummariesResponseData
     */
    'months': Array<IMonthSummary>;
    /**
     * The knowledge of the server
     * @type {number}
     * @memberof IMonthSummariesResponseData
     */
    'server_knowledge': number;
}
/**
 * 
 * @export
 * @interface IMonthSummary
 */
export interface IMonthSummary {
    /**
     * 
     * @type {string}
     * @memberof IMonthSummary
     */
    'month': string;
    /**
     * 
     * @type {string}
     * @memberof IMonthSummary
     */
    'note'?: string;
    /**
     * The total amount of transactions categorized to \'Inflow: Ready to Assign\' in the month
     * @type {number}
     * @memberof IMonthSummary
     */
    'income': number;
    /**
     * The total amount budgeted in the month
     * @type {number}
     * @memberof IMonthSummary
     */
    'budgeted': number;
    /**
     * The total amount of transactions in the month, excluding those categorized to \'Inflow: Ready to Assign\'
     * @type {number}
     * @memberof IMonthSummary
     */
    'activity': number;
    /**
     * The available amount for \'Ready to Assign\'
     * @type {number}
     * @memberof IMonthSummary
     */
    'to_be_budgeted': number;
    /**
     * The Age of Money as of the month
     * @type {number}
     * @memberof IMonthSummary
     */
    'age_of_money'?: number;
    /**
     * Whether or not the month has been deleted.  Deleted months will only be included in delta requests.
     * @type {boolean}
     * @memberof IMonthSummary
     */
    'deleted': boolean;
}
/**
 * 
 * @export
 * @interface IPayee
 */
export interface IPayee {
    /**
     * 
     * @type {string}
     * @memberof IPayee
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof IPayee
     */
    'name': string;
    /**
     * If a transfer payee, the `account_id` to which this payee transfers to
     * @type {string}
     * @memberof IPayee
     */
    'transfer_account_id'?: string;
    /**
     * Whether or not the payee has been deleted.  Deleted payees will only be included in delta requests.
     * @type {boolean}
     * @memberof IPayee
     */
    'deleted': boolean;
}
/**
 * 
 * @export
 * @interface IPayeeLocation
 */
export interface IPayeeLocation {
    /**
     * 
     * @type {string}
     * @memberof IPayeeLocation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof IPayeeLocation
     */
    'payee_id': string;
    /**
     * 
     * @type {string}
     * @memberof IPayeeLocation
     */
    'latitude': string;
    /**
     * 
     * @type {string}
     * @memberof IPayeeLocation
     */
    'longitude': string;
    /**
     * Whether or not the payee location has been deleted.  Deleted payee locations will only be included in delta requests.
     * @type {boolean}
     * @memberof IPayeeLocation
     */
    'deleted': boolean;
}
/**
 * 
 * @export
 * @interface IPayeeLocationResponse
 */
export interface IPayeeLocationResponse {
    /**
     * 
     * @type {IPayeeLocationResponseData}
     * @memberof IPayeeLocationResponse
     */
    'data': IPayeeLocationResponseData;
}
/**
 * 
 * @export
 * @interface IPayeeLocationResponseData
 */
export interface IPayeeLocationResponseData {
    /**
     * 
     * @type {IPayeeLocation}
     * @memberof IPayeeLocationResponseData
     */
    'payee_location': IPayeeLocation;
}
/**
 * 
 * @export
 * @interface IPayeeLocationsResponse
 */
export interface IPayeeLocationsResponse {
    /**
     * 
     * @type {IPayeeLocationsResponseData}
     * @memberof IPayeeLocationsResponse
     */
    'data': IPayeeLocationsResponseData;
}
/**
 * 
 * @export
 * @interface IPayeeLocationsResponseData
 */
export interface IPayeeLocationsResponseData {
    /**
     * 
     * @type {Array<IPayeeLocation>}
     * @memberof IPayeeLocationsResponseData
     */
    'payee_locations': Array<IPayeeLocation>;
}
/**
 * 
 * @export
 * @interface IPayeeResponse
 */
export interface IPayeeResponse {
    /**
     * 
     * @type {IPayeeResponseData}
     * @memberof IPayeeResponse
     */
    'data': IPayeeResponseData;
}
/**
 * 
 * @export
 * @interface IPayeeResponseData
 */
export interface IPayeeResponseData {
    /**
     * 
     * @type {IPayee}
     * @memberof IPayeeResponseData
     */
    'payee': IPayee;
}
/**
 * 
 * @export
 * @interface IPayeesResponse
 */
export interface IPayeesResponse {
    /**
     * 
     * @type {IPayeesResponseData}
     * @memberof IPayeesResponse
     */
    'data': IPayeesResponseData;
}
/**
 * 
 * @export
 * @interface IPayeesResponseData
 */
export interface IPayeesResponseData {
    /**
     * 
     * @type {Array<IPayee>}
     * @memberof IPayeesResponseData
     */
    'payees': Array<IPayee>;
    /**
     * The knowledge of the server
     * @type {number}
     * @memberof IPayeesResponseData
     */
    'server_knowledge': number;
}
/**
 * 
 * @export
 * @interface ISaveAccount
 */
export interface ISaveAccount {
    /**
     * The name of the account
     * @type {string}
     * @memberof ISaveAccount
     */
    'name': string;
    /**
     * The account type
     * @type {string}
     * @memberof ISaveAccount
     */
    'type': ISaveAccountTypeEnum;
    /**
     * The current balance of the account in milliunits format
     * @type {number}
     * @memberof ISaveAccount
     */
    'balance': number;
}

export const ISaveAccountTypeEnum = {
    Checking: 'checking',
    Savings: 'savings',
    CreditCard: 'creditCard',
    Cash: 'cash',
    LineOfCredit: 'lineOfCredit',
    OtherAsset: 'otherAsset',
    OtherLiability: 'otherLiability'
} as const;

export type ISaveAccountTypeEnum = typeof ISaveAccountTypeEnum[keyof typeof ISaveAccountTypeEnum];

/**
 * 
 * @export
 * @interface ISaveAccountWrapper
 */
export interface ISaveAccountWrapper {
    /**
     * 
     * @type {ISaveAccount}
     * @memberof ISaveAccountWrapper
     */
    'account': ISaveAccount;
}
/**
 * 
 * @export
 * @interface ISaveCategoryResponse
 */
export interface ISaveCategoryResponse {
    /**
     * 
     * @type {ISaveCategoryResponseData}
     * @memberof ISaveCategoryResponse
     */
    'data': ISaveCategoryResponseData;
}
/**
 * 
 * @export
 * @interface ISaveCategoryResponseData
 */
export interface ISaveCategoryResponseData {
    /**
     * 
     * @type {ICategory}
     * @memberof ISaveCategoryResponseData
     */
    'category': ICategory;
    /**
     * The knowledge of the server
     * @type {number}
     * @memberof ISaveCategoryResponseData
     */
    'server_knowledge': number;
}
/**
 * 
 * @export
 * @interface ISaveMonthCategory
 */
export interface ISaveMonthCategory {
    /**
     * Budgeted amount in milliunits format
     * @type {number}
     * @memberof ISaveMonthCategory
     */
    'budgeted': number;
}
/**
 * 
 * @export
 * @interface ISaveMonthCategoryWrapper
 */
export interface ISaveMonthCategoryWrapper {
    /**
     * 
     * @type {ISaveMonthCategory}
     * @memberof ISaveMonthCategoryWrapper
     */
    'category': ISaveMonthCategory;
}
/**
 * 
 * @export
 * @interface ISaveSubTransaction
 */
export interface ISaveSubTransaction {
    /**
     * The subtransaction amount in milliunits format.
     * @type {number}
     * @memberof ISaveSubTransaction
     */
    'amount': number;
    /**
     * The payee for the subtransaction.
     * @type {string}
     * @memberof ISaveSubTransaction
     */
    'payee_id'?: string;
    /**
     * The payee name.  If a `payee_name` value is provided and `payee_id` has a null value, the `payee_name` value will be used to resolve the payee by either (1) a matching payee rename rule (only if import_id is also specified on parent transaction) or (2) a payee with the same name or (3) creation of a new payee.
     * @type {string}
     * @memberof ISaveSubTransaction
     */
    'payee_name'?: string;
    /**
     * The category for the subtransaction.  Credit Card Payment categories are not permitted and will be ignored if supplied.
     * @type {string}
     * @memberof ISaveSubTransaction
     */
    'category_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ISaveSubTransaction
     */
    'memo'?: string;
}
/**
 * 
 * @export
 * @interface ISaveTransaction
 */
export interface ISaveTransaction {
    /**
     * 
     * @type {string}
     * @memberof ISaveTransaction
     */
    'account_id': string;
    /**
     * The transaction date in ISO format (e.g. 2016-12-01).  Future dates (scheduled transactions) are not permitted.  Split transaction dates cannot be changed and if a different date is supplied it will be ignored.
     * @type {string}
     * @memberof ISaveTransaction
     */
    'date': string;
    /**
     * The transaction amount in milliunits format.  Split transaction amounts cannot be changed and if a different amount is supplied it will be ignored.
     * @type {number}
     * @memberof ISaveTransaction
     */
    'amount': number;
    /**
     * The payee for the transaction.  To create a transfer between two accounts, use the account transfer payee pointing to the target account.  Account transfer payees are specified as `tranfer_payee_id` on the account resource.
     * @type {string}
     * @memberof ISaveTransaction
     */
    'payee_id'?: string;
    /**
     * The payee name.  If a `payee_name` value is provided and `payee_id` has a null value, the `payee_name` value will be used to resolve the payee by either (1) a matching payee rename rule (only if `import_id` is also specified) or (2) a payee with the same name or (3) creation of a new payee.
     * @type {string}
     * @memberof ISaveTransaction
     */
    'payee_name'?: string;
    /**
     * The category for the transaction.  To configure a split transaction, you can specify null for `category_id` and provide a `subtransactions` array as part of the transaction object.  If an existing transaction is a split, the `category_id` cannot be changed.  Credit Card Payment categories are not permitted and will be ignored if supplied.
     * @type {string}
     * @memberof ISaveTransaction
     */
    'category_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ISaveTransaction
     */
    'memo'?: string;
    /**
     * The cleared status of the transaction
     * @type {string}
     * @memberof ISaveTransaction
     */
    'cleared'?: ISaveTransactionClearedEnum;
    /**
     * Whether or not the transaction is approved.  If not supplied, transaction will be unapproved by default.
     * @type {boolean}
     * @memberof ISaveTransaction
     */
    'approved'?: boolean;
    /**
     * The transaction flag
     * @type {string}
     * @memberof ISaveTransaction
     */
    'flag_color'?: ISaveTransactionFlagColorEnum;
    /**
     * If specified, the new transaction will be assigned this `import_id` and considered \"imported\".  We will also attempt to match this imported transaction to an existing \"user-entered\" transation on the same account, with the same amount, and with a date +/-10 days from the imported transaction date.<br><br>Transactions imported through File Based Import or Direct Import (not through the API) are assigned an import_id in the format: \'YNAB:[milliunit_amount]:[iso_date]:[occurrence]\'. For example, a transaction dated 2015-12-30 in the amount of -$294.23 USD would have an import_id of \'YNAB:-294230:2015-12-30:1\'.  If a second transaction on the same account was imported and had the same date and same amount, its import_id would be \'YNAB:-294230:2015-12-30:2\'.  Using a consistent format will prevent duplicates through Direct Import and File Based Import.<br><br>If import_id is omitted or specified as null, the transaction will be treated as a \"user-entered\" transaction. As such, it will be eligible to be matched against transactions later being imported (via DI, FBI, or API).
     * @type {string}
     * @memberof ISaveTransaction
     */
    'import_id'?: string;
    /**
     * An array of subtransactions to configure a transaction as a split.  Updating `subtransactions` on an existing split transaction is not supported.
     * @type {Array<ISaveSubTransaction>}
     * @memberof ISaveTransaction
     */
    'subtransactions'?: Array<ISaveSubTransaction>;
}

export const ISaveTransactionClearedEnum = {
    Cleared: 'cleared',
    Uncleared: 'uncleared',
    Reconciled: 'reconciled'
} as const;

export type ISaveTransactionClearedEnum = typeof ISaveTransactionClearedEnum[keyof typeof ISaveTransactionClearedEnum];
export const ISaveTransactionFlagColorEnum = {
    Red: 'red',
    Orange: 'orange',
    Yellow: 'yellow',
    Green: 'green',
    Blue: 'blue',
    Purple: 'purple'
} as const;

export type ISaveTransactionFlagColorEnum = typeof ISaveTransactionFlagColorEnum[keyof typeof ISaveTransactionFlagColorEnum];

/**
 * 
 * @export
 * @interface ISaveTransactionWrapper
 */
export interface ISaveTransactionWrapper {
    /**
     * 
     * @type {ISaveTransaction}
     * @memberof ISaveTransactionWrapper
     */
    'transaction': ISaveTransaction;
}
/**
 * 
 * @export
 * @interface ISaveTransactionsResponse
 */
export interface ISaveTransactionsResponse {
    /**
     * 
     * @type {ISaveTransactionsResponseData}
     * @memberof ISaveTransactionsResponse
     */
    'data': ISaveTransactionsResponseData;
}
/**
 * 
 * @export
 * @interface ISaveTransactionsResponseData
 */
export interface ISaveTransactionsResponseData {
    /**
     * The transaction ids that were saved
     * @type {Array<string>}
     * @memberof ISaveTransactionsResponseData
     */
    'transaction_ids': Array<string>;
    /**
     * 
     * @type {ITransactionDetail}
     * @memberof ISaveTransactionsResponseData
     */
    'transaction'?: ITransactionDetail;
    /**
     * If multiple transactions were specified, the transactions that were saved
     * @type {Array<ITransactionDetail>}
     * @memberof ISaveTransactionsResponseData
     */
    'transactions'?: Array<ITransactionDetail>;
    /**
     * If multiple transactions were specified, a list of import_ids that were not created because of an existing `import_id` found on the same account
     * @type {Array<string>}
     * @memberof ISaveTransactionsResponseData
     */
    'duplicate_import_ids'?: Array<string>;
    /**
     * The knowledge of the server
     * @type {number}
     * @memberof ISaveTransactionsResponseData
     */
    'server_knowledge': number;
}
/**
 * 
 * @export
 * @interface ISaveTransactionsWrapper
 */
export interface ISaveTransactionsWrapper {
    /**
     * 
     * @type {ISaveTransaction}
     * @memberof ISaveTransactionsWrapper
     */
    'transaction'?: ISaveTransaction;
    /**
     * 
     * @type {Array<ISaveTransaction>}
     * @memberof ISaveTransactionsWrapper
     */
    'transactions'?: Array<ISaveTransaction>;
}
/**
 * 
 * @export
 * @interface IScheduledSubTransaction
 */
export interface IScheduledSubTransaction {
    /**
     * 
     * @type {string}
     * @memberof IScheduledSubTransaction
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof IScheduledSubTransaction
     */
    'scheduled_transaction_id': string;
    /**
     * The scheduled subtransaction amount in milliunits format
     * @type {number}
     * @memberof IScheduledSubTransaction
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof IScheduledSubTransaction
     */
    'memo'?: string;
    /**
     * 
     * @type {string}
     * @memberof IScheduledSubTransaction
     */
    'payee_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IScheduledSubTransaction
     */
    'category_id'?: string;
    /**
     * If a transfer, the account_id which the scheduled subtransaction transfers to
     * @type {string}
     * @memberof IScheduledSubTransaction
     */
    'transfer_account_id'?: string;
    /**
     * Whether or not the scheduled subtransaction has been deleted.  Deleted scheduled subtransactions will only be included in delta requests.
     * @type {boolean}
     * @memberof IScheduledSubTransaction
     */
    'deleted': boolean;
}
/**
 * 
 * @export
 * @interface IScheduledTransactionDetail
 */
export interface IScheduledTransactionDetail {
    /**
     * 
     * @type {string}
     * @memberof IScheduledTransactionDetail
     */
    'id': string;
    /**
     * The first date for which the Scheduled Transaction was scheduled.
     * @type {string}
     * @memberof IScheduledTransactionDetail
     */
    'date_first': string;
    /**
     * The next date for which the Scheduled Transaction is scheduled.
     * @type {string}
     * @memberof IScheduledTransactionDetail
     */
    'date_next': string;
    /**
     * 
     * @type {string}
     * @memberof IScheduledTransactionDetail
     */
    'frequency': IScheduledTransactionDetailFrequencyEnum;
    /**
     * The scheduled transaction amount in milliunits format
     * @type {number}
     * @memberof IScheduledTransactionDetail
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof IScheduledTransactionDetail
     */
    'memo'?: string;
    /**
     * The scheduled transaction flag
     * @type {string}
     * @memberof IScheduledTransactionDetail
     */
    'flag_color'?: IScheduledTransactionDetailFlagColorEnum;
    /**
     * 
     * @type {string}
     * @memberof IScheduledTransactionDetail
     */
    'account_id': string;
    /**
     * 
     * @type {string}
     * @memberof IScheduledTransactionDetail
     */
    'payee_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IScheduledTransactionDetail
     */
    'category_id'?: string;
    /**
     * If a transfer, the account_id which the scheduled transaction transfers to
     * @type {string}
     * @memberof IScheduledTransactionDetail
     */
    'transfer_account_id'?: string;
    /**
     * Whether or not the scheduled transaction has been deleted.  Deleted scheduled transactions will only be included in delta requests.
     * @type {boolean}
     * @memberof IScheduledTransactionDetail
     */
    'deleted': boolean;
    /**
     * 
     * @type {string}
     * @memberof IScheduledTransactionDetail
     */
    'account_name': string;
    /**
     * 
     * @type {string}
     * @memberof IScheduledTransactionDetail
     */
    'payee_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof IScheduledTransactionDetail
     */
    'category_name'?: string;
    /**
     * If a split scheduled transaction, the subtransactions.
     * @type {Array<IScheduledSubTransaction>}
     * @memberof IScheduledTransactionDetail
     */
    'subtransactions': Array<IScheduledSubTransaction>;
}

export const IScheduledTransactionDetailFrequencyEnum = {
    Never: 'never',
    Daily: 'daily',
    Weekly: 'weekly',
    EveryOtherWeek: 'everyOtherWeek',
    TwiceAMonth: 'twiceAMonth',
    Every4Weeks: 'every4Weeks',
    Monthly: 'monthly',
    EveryOtherMonth: 'everyOtherMonth',
    Every3Months: 'every3Months',
    Every4Months: 'every4Months',
    TwiceAYear: 'twiceAYear',
    Yearly: 'yearly',
    EveryOtherYear: 'everyOtherYear'
} as const;

export type IScheduledTransactionDetailFrequencyEnum = typeof IScheduledTransactionDetailFrequencyEnum[keyof typeof IScheduledTransactionDetailFrequencyEnum];
export const IScheduledTransactionDetailFlagColorEnum = {
    Red: 'red',
    Orange: 'orange',
    Yellow: 'yellow',
    Green: 'green',
    Blue: 'blue',
    Purple: 'purple'
} as const;

export type IScheduledTransactionDetailFlagColorEnum = typeof IScheduledTransactionDetailFlagColorEnum[keyof typeof IScheduledTransactionDetailFlagColorEnum];

/**
 * 
 * @export
 * @interface IScheduledTransactionDetailAllOf
 */
export interface IScheduledTransactionDetailAllOf {
    /**
     * 
     * @type {string}
     * @memberof IScheduledTransactionDetailAllOf
     */
    'account_name': string;
    /**
     * 
     * @type {string}
     * @memberof IScheduledTransactionDetailAllOf
     */
    'payee_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof IScheduledTransactionDetailAllOf
     */
    'category_name'?: string;
    /**
     * If a split scheduled transaction, the subtransactions.
     * @type {Array<IScheduledSubTransaction>}
     * @memberof IScheduledTransactionDetailAllOf
     */
    'subtransactions': Array<IScheduledSubTransaction>;
}
/**
 * 
 * @export
 * @interface IScheduledTransactionResponse
 */
export interface IScheduledTransactionResponse {
    /**
     * 
     * @type {IScheduledTransactionResponseData}
     * @memberof IScheduledTransactionResponse
     */
    'data': IScheduledTransactionResponseData;
}
/**
 * 
 * @export
 * @interface IScheduledTransactionResponseData
 */
export interface IScheduledTransactionResponseData {
    /**
     * 
     * @type {IScheduledTransactionDetail}
     * @memberof IScheduledTransactionResponseData
     */
    'scheduled_transaction': IScheduledTransactionDetail;
}
/**
 * 
 * @export
 * @interface IScheduledTransactionSummary
 */
export interface IScheduledTransactionSummary {
    /**
     * 
     * @type {string}
     * @memberof IScheduledTransactionSummary
     */
    'id': string;
    /**
     * The first date for which the Scheduled Transaction was scheduled.
     * @type {string}
     * @memberof IScheduledTransactionSummary
     */
    'date_first': string;
    /**
     * The next date for which the Scheduled Transaction is scheduled.
     * @type {string}
     * @memberof IScheduledTransactionSummary
     */
    'date_next': string;
    /**
     * 
     * @type {string}
     * @memberof IScheduledTransactionSummary
     */
    'frequency': IScheduledTransactionSummaryFrequencyEnum;
    /**
     * The scheduled transaction amount in milliunits format
     * @type {number}
     * @memberof IScheduledTransactionSummary
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof IScheduledTransactionSummary
     */
    'memo'?: string;
    /**
     * The scheduled transaction flag
     * @type {string}
     * @memberof IScheduledTransactionSummary
     */
    'flag_color'?: IScheduledTransactionSummaryFlagColorEnum;
    /**
     * 
     * @type {string}
     * @memberof IScheduledTransactionSummary
     */
    'account_id': string;
    /**
     * 
     * @type {string}
     * @memberof IScheduledTransactionSummary
     */
    'payee_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IScheduledTransactionSummary
     */
    'category_id'?: string;
    /**
     * If a transfer, the account_id which the scheduled transaction transfers to
     * @type {string}
     * @memberof IScheduledTransactionSummary
     */
    'transfer_account_id'?: string;
    /**
     * Whether or not the scheduled transaction has been deleted.  Deleted scheduled transactions will only be included in delta requests.
     * @type {boolean}
     * @memberof IScheduledTransactionSummary
     */
    'deleted': boolean;
}

export const IScheduledTransactionSummaryFrequencyEnum = {
    Never: 'never',
    Daily: 'daily',
    Weekly: 'weekly',
    EveryOtherWeek: 'everyOtherWeek',
    TwiceAMonth: 'twiceAMonth',
    Every4Weeks: 'every4Weeks',
    Monthly: 'monthly',
    EveryOtherMonth: 'everyOtherMonth',
    Every3Months: 'every3Months',
    Every4Months: 'every4Months',
    TwiceAYear: 'twiceAYear',
    Yearly: 'yearly',
    EveryOtherYear: 'everyOtherYear'
} as const;

export type IScheduledTransactionSummaryFrequencyEnum = typeof IScheduledTransactionSummaryFrequencyEnum[keyof typeof IScheduledTransactionSummaryFrequencyEnum];
export const IScheduledTransactionSummaryFlagColorEnum = {
    Red: 'red',
    Orange: 'orange',
    Yellow: 'yellow',
    Green: 'green',
    Blue: 'blue',
    Purple: 'purple'
} as const;

export type IScheduledTransactionSummaryFlagColorEnum = typeof IScheduledTransactionSummaryFlagColorEnum[keyof typeof IScheduledTransactionSummaryFlagColorEnum];

/**
 * 
 * @export
 * @interface IScheduledTransactionsResponse
 */
export interface IScheduledTransactionsResponse {
    /**
     * 
     * @type {IScheduledTransactionsResponseData}
     * @memberof IScheduledTransactionsResponse
     */
    'data': IScheduledTransactionsResponseData;
}
/**
 * 
 * @export
 * @interface IScheduledTransactionsResponseData
 */
export interface IScheduledTransactionsResponseData {
    /**
     * 
     * @type {Array<IScheduledTransactionDetail>}
     * @memberof IScheduledTransactionsResponseData
     */
    'scheduled_transactions': Array<IScheduledTransactionDetail>;
    /**
     * The knowledge of the server
     * @type {number}
     * @memberof IScheduledTransactionsResponseData
     */
    'server_knowledge': number;
}
/**
 * 
 * @export
 * @interface ISubTransaction
 */
export interface ISubTransaction {
    /**
     * 
     * @type {string}
     * @memberof ISubTransaction
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ISubTransaction
     */
    'transaction_id': string;
    /**
     * The subtransaction amount in milliunits format
     * @type {number}
     * @memberof ISubTransaction
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof ISubTransaction
     */
    'memo'?: string;
    /**
     * 
     * @type {string}
     * @memberof ISubTransaction
     */
    'payee_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ISubTransaction
     */
    'payee_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ISubTransaction
     */
    'category_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ISubTransaction
     */
    'category_name'?: string;
    /**
     * If a transfer, the account_id which the subtransaction transfers to
     * @type {string}
     * @memberof ISubTransaction
     */
    'transfer_account_id'?: string;
    /**
     * If a transfer, the id of transaction on the other side of the transfer
     * @type {string}
     * @memberof ISubTransaction
     */
    'transfer_transaction_id'?: string;
    /**
     * Whether or not the subtransaction has been deleted.  Deleted subtransactions will only be included in delta requests.
     * @type {boolean}
     * @memberof ISubTransaction
     */
    'deleted': boolean;
}
/**
 * 
 * @export
 * @interface ITransactionDetail
 */
export interface ITransactionDetail {
    /**
     * 
     * @type {string}
     * @memberof ITransactionDetail
     */
    'id': string;
    /**
     * The transaction date in ISO format (e.g. 2016-12-01)
     * @type {string}
     * @memberof ITransactionDetail
     */
    'date': string;
    /**
     * The transaction amount in milliunits format
     * @type {number}
     * @memberof ITransactionDetail
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof ITransactionDetail
     */
    'memo'?: string;
    /**
     * The cleared status of the transaction
     * @type {string}
     * @memberof ITransactionDetail
     */
    'cleared': ITransactionDetailClearedEnum;
    /**
     * Whether or not the transaction is approved
     * @type {boolean}
     * @memberof ITransactionDetail
     */
    'approved': boolean;
    /**
     * The transaction flag
     * @type {string}
     * @memberof ITransactionDetail
     */
    'flag_color'?: ITransactionDetailFlagColorEnum;
    /**
     * 
     * @type {string}
     * @memberof ITransactionDetail
     */
    'account_id': string;
    /**
     * 
     * @type {string}
     * @memberof ITransactionDetail
     */
    'payee_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ITransactionDetail
     */
    'category_id'?: string;
    /**
     * If a transfer transaction, the account to which it transfers
     * @type {string}
     * @memberof ITransactionDetail
     */
    'transfer_account_id'?: string;
    /**
     * If a transfer transaction, the id of transaction on the other side of the transfer
     * @type {string}
     * @memberof ITransactionDetail
     */
    'transfer_transaction_id'?: string;
    /**
     * If transaction is matched, the id of the matched transaction
     * @type {string}
     * @memberof ITransactionDetail
     */
    'matched_transaction_id'?: string;
    /**
     * If the Transaction was imported, this field is a unique (by account) import identifier.  If this transaction was imported through File Based Import or Direct Import and not through the API, the import_id will have the format: \'YNAB:[milliunit_amount]:[iso_date]:[occurrence]\'.  For example, a transaction dated 2015-12-30 in the amount of -$294.23 USD would have an import_id of \'YNAB:-294230:2015-12-30:1\'.  If a second transaction on the same account was imported and had the same date and same amount, its import_id would be \'YNAB:-294230:2015-12-30:2\'.
     * @type {string}
     * @memberof ITransactionDetail
     */
    'import_id'?: string;
    /**
     * Whether or not the transaction has been deleted.  Deleted transactions will only be included in delta requests.
     * @type {boolean}
     * @memberof ITransactionDetail
     */
    'deleted': boolean;
    /**
     * 
     * @type {string}
     * @memberof ITransactionDetail
     */
    'account_name': string;
    /**
     * 
     * @type {string}
     * @memberof ITransactionDetail
     */
    'payee_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ITransactionDetail
     */
    'category_name'?: string;
    /**
     * If a split transaction, the subtransactions.
     * @type {Array<ISubTransaction>}
     * @memberof ITransactionDetail
     */
    'subtransactions': Array<ISubTransaction>;
}

export const ITransactionDetailClearedEnum = {
    Cleared: 'cleared',
    Uncleared: 'uncleared',
    Reconciled: 'reconciled'
} as const;

export type ITransactionDetailClearedEnum = typeof ITransactionDetailClearedEnum[keyof typeof ITransactionDetailClearedEnum];
export const ITransactionDetailFlagColorEnum = {
    Red: 'red',
    Orange: 'orange',
    Yellow: 'yellow',
    Green: 'green',
    Blue: 'blue',
    Purple: 'purple'
} as const;

export type ITransactionDetailFlagColorEnum = typeof ITransactionDetailFlagColorEnum[keyof typeof ITransactionDetailFlagColorEnum];

/**
 * 
 * @export
 * @interface ITransactionDetailAllOf
 */
export interface ITransactionDetailAllOf {
    /**
     * 
     * @type {string}
     * @memberof ITransactionDetailAllOf
     */
    'account_name': string;
    /**
     * 
     * @type {string}
     * @memberof ITransactionDetailAllOf
     */
    'payee_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ITransactionDetailAllOf
     */
    'category_name'?: string;
    /**
     * If a split transaction, the subtransactions.
     * @type {Array<ISubTransaction>}
     * @memberof ITransactionDetailAllOf
     */
    'subtransactions': Array<ISubTransaction>;
}
/**
 * 
 * @export
 * @interface ITransactionResponse
 */
export interface ITransactionResponse {
    /**
     * 
     * @type {ITransactionResponseData}
     * @memberof ITransactionResponse
     */
    'data': ITransactionResponseData;
}
/**
 * 
 * @export
 * @interface ITransactionResponseData
 */
export interface ITransactionResponseData {
    /**
     * 
     * @type {ITransactionDetail}
     * @memberof ITransactionResponseData
     */
    'transaction': ITransactionDetail;
}
/**
 * 
 * @export
 * @interface ITransactionSummary
 */
export interface ITransactionSummary {
    /**
     * 
     * @type {string}
     * @memberof ITransactionSummary
     */
    'id': string;
    /**
     * The transaction date in ISO format (e.g. 2016-12-01)
     * @type {string}
     * @memberof ITransactionSummary
     */
    'date': string;
    /**
     * The transaction amount in milliunits format
     * @type {number}
     * @memberof ITransactionSummary
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof ITransactionSummary
     */
    'memo'?: string;
    /**
     * The cleared status of the transaction
     * @type {string}
     * @memberof ITransactionSummary
     */
    'cleared': ITransactionSummaryClearedEnum;
    /**
     * Whether or not the transaction is approved
     * @type {boolean}
     * @memberof ITransactionSummary
     */
    'approved': boolean;
    /**
     * The transaction flag
     * @type {string}
     * @memberof ITransactionSummary
     */
    'flag_color'?: ITransactionSummaryFlagColorEnum;
    /**
     * 
     * @type {string}
     * @memberof ITransactionSummary
     */
    'account_id': string;
    /**
     * 
     * @type {string}
     * @memberof ITransactionSummary
     */
    'payee_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ITransactionSummary
     */
    'category_id'?: string;
    /**
     * If a transfer transaction, the account to which it transfers
     * @type {string}
     * @memberof ITransactionSummary
     */
    'transfer_account_id'?: string;
    /**
     * If a transfer transaction, the id of transaction on the other side of the transfer
     * @type {string}
     * @memberof ITransactionSummary
     */
    'transfer_transaction_id'?: string;
    /**
     * If transaction is matched, the id of the matched transaction
     * @type {string}
     * @memberof ITransactionSummary
     */
    'matched_transaction_id'?: string;
    /**
     * If the Transaction was imported, this field is a unique (by account) import identifier.  If this transaction was imported through File Based Import or Direct Import and not through the API, the import_id will have the format: \'YNAB:[milliunit_amount]:[iso_date]:[occurrence]\'.  For example, a transaction dated 2015-12-30 in the amount of -$294.23 USD would have an import_id of \'YNAB:-294230:2015-12-30:1\'.  If a second transaction on the same account was imported and had the same date and same amount, its import_id would be \'YNAB:-294230:2015-12-30:2\'.
     * @type {string}
     * @memberof ITransactionSummary
     */
    'import_id'?: string;
    /**
     * Whether or not the transaction has been deleted.  Deleted transactions will only be included in delta requests.
     * @type {boolean}
     * @memberof ITransactionSummary
     */
    'deleted': boolean;
}

export const ITransactionSummaryClearedEnum = {
    Cleared: 'cleared',
    Uncleared: 'uncleared',
    Reconciled: 'reconciled'
} as const;

export type ITransactionSummaryClearedEnum = typeof ITransactionSummaryClearedEnum[keyof typeof ITransactionSummaryClearedEnum];
export const ITransactionSummaryFlagColorEnum = {
    Red: 'red',
    Orange: 'orange',
    Yellow: 'yellow',
    Green: 'green',
    Blue: 'blue',
    Purple: 'purple'
} as const;

export type ITransactionSummaryFlagColorEnum = typeof ITransactionSummaryFlagColorEnum[keyof typeof ITransactionSummaryFlagColorEnum];

/**
 * 
 * @export
 * @interface ITransactionsImportResponse
 */
export interface ITransactionsImportResponse {
    /**
     * 
     * @type {ITransactionsImportResponseData}
     * @memberof ITransactionsImportResponse
     */
    'data': ITransactionsImportResponseData;
}
/**
 * 
 * @export
 * @interface ITransactionsImportResponseData
 */
export interface ITransactionsImportResponseData {
    /**
     * The list of transaction ids that were imported.
     * @type {Array<string>}
     * @memberof ITransactionsImportResponseData
     */
    'transaction_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface ITransactionsResponse
 */
export interface ITransactionsResponse {
    /**
     * 
     * @type {ITransactionsResponseData}
     * @memberof ITransactionsResponse
     */
    'data': ITransactionsResponseData;
}
/**
 * 
 * @export
 * @interface ITransactionsResponseData
 */
export interface ITransactionsResponseData {
    /**
     * 
     * @type {Array<ITransactionDetail>}
     * @memberof ITransactionsResponseData
     */
    'transactions': Array<ITransactionDetail>;
    /**
     * The knowledge of the server
     * @type {number}
     * @memberof ITransactionsResponseData
     */
    'server_knowledge': number;
}
/**
 * 
 * @export
 * @interface IUpdateTransaction
 */
export interface IUpdateTransaction {
    /**
     * 
     * @type {string}
     * @memberof IUpdateTransaction
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof IUpdateTransaction
     */
    'account_id': string;
    /**
     * The transaction date in ISO format (e.g. 2016-12-01).  Future dates (scheduled transactions) are not permitted.  Split transaction dates cannot be changed and if a different date is supplied it will be ignored.
     * @type {string}
     * @memberof IUpdateTransaction
     */
    'date': string;
    /**
     * The transaction amount in milliunits format.  Split transaction amounts cannot be changed and if a different amount is supplied it will be ignored.
     * @type {number}
     * @memberof IUpdateTransaction
     */
    'amount': number;
    /**
     * The payee for the transaction.  To create a transfer between two accounts, use the account transfer payee pointing to the target account.  Account transfer payees are specified as `tranfer_payee_id` on the account resource.
     * @type {string}
     * @memberof IUpdateTransaction
     */
    'payee_id'?: string;
    /**
     * The payee name.  If a `payee_name` value is provided and `payee_id` has a null value, the `payee_name` value will be used to resolve the payee by either (1) a matching payee rename rule (only if `import_id` is also specified) or (2) a payee with the same name or (3) creation of a new payee.
     * @type {string}
     * @memberof IUpdateTransaction
     */
    'payee_name'?: string;
    /**
     * The category for the transaction.  To configure a split transaction, you can specify null for `category_id` and provide a `subtransactions` array as part of the transaction object.  If an existing transaction is a split, the `category_id` cannot be changed.  Credit Card Payment categories are not permitted and will be ignored if supplied.
     * @type {string}
     * @memberof IUpdateTransaction
     */
    'category_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IUpdateTransaction
     */
    'memo'?: string;
    /**
     * The cleared status of the transaction
     * @type {string}
     * @memberof IUpdateTransaction
     */
    'cleared'?: IUpdateTransactionClearedEnum;
    /**
     * Whether or not the transaction is approved.  If not supplied, transaction will be unapproved by default.
     * @type {boolean}
     * @memberof IUpdateTransaction
     */
    'approved'?: boolean;
    /**
     * The transaction flag
     * @type {string}
     * @memberof IUpdateTransaction
     */
    'flag_color'?: IUpdateTransactionFlagColorEnum;
    /**
     * If specified, the new transaction will be assigned this `import_id` and considered \"imported\".  We will also attempt to match this imported transaction to an existing \"user-entered\" transation on the same account, with the same amount, and with a date +/-10 days from the imported transaction date.<br><br>Transactions imported through File Based Import or Direct Import (not through the API) are assigned an import_id in the format: \'YNAB:[milliunit_amount]:[iso_date]:[occurrence]\'. For example, a transaction dated 2015-12-30 in the amount of -$294.23 USD would have an import_id of \'YNAB:-294230:2015-12-30:1\'.  If a second transaction on the same account was imported and had the same date and same amount, its import_id would be \'YNAB:-294230:2015-12-30:2\'.  Using a consistent format will prevent duplicates through Direct Import and File Based Import.<br><br>If import_id is omitted or specified as null, the transaction will be treated as a \"user-entered\" transaction. As such, it will be eligible to be matched against transactions later being imported (via DI, FBI, or API).
     * @type {string}
     * @memberof IUpdateTransaction
     */
    'import_id'?: string;
    /**
     * An array of subtransactions to configure a transaction as a split.  Updating `subtransactions` on an existing split transaction is not supported.
     * @type {Array<ISaveSubTransaction>}
     * @memberof IUpdateTransaction
     */
    'subtransactions'?: Array<ISaveSubTransaction>;
}

export const IUpdateTransactionClearedEnum = {
    Cleared: 'cleared',
    Uncleared: 'uncleared',
    Reconciled: 'reconciled'
} as const;

export type IUpdateTransactionClearedEnum = typeof IUpdateTransactionClearedEnum[keyof typeof IUpdateTransactionClearedEnum];
export const IUpdateTransactionFlagColorEnum = {
    Red: 'red',
    Orange: 'orange',
    Yellow: 'yellow',
    Green: 'green',
    Blue: 'blue',
    Purple: 'purple'
} as const;

export type IUpdateTransactionFlagColorEnum = typeof IUpdateTransactionFlagColorEnum[keyof typeof IUpdateTransactionFlagColorEnum];

/**
 * 
 * @export
 * @interface IUpdateTransactionAllOf
 */
export interface IUpdateTransactionAllOf {
    /**
     * 
     * @type {string}
     * @memberof IUpdateTransactionAllOf
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface IUpdateTransactionsWrapper
 */
export interface IUpdateTransactionsWrapper {
    /**
     * 
     * @type {Array<IUpdateTransaction>}
     * @memberof IUpdateTransactionsWrapper
     */
    'transactions': Array<IUpdateTransaction>;
}
/**
 * 
 * @export
 * @interface IUser
 */
export interface IUser {
    /**
     * 
     * @type {string}
     * @memberof IUser
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface IUserResponse
 */
export interface IUserResponse {
    /**
     * 
     * @type {IUserResponseData}
     * @memberof IUserResponse
     */
    'data': IUserResponseData;
}
/**
 * 
 * @export
 * @interface IUserResponseData
 */
export interface IUserResponseData {
    /**
     * 
     * @type {IUser}
     * @memberof IUserResponseData
     */
    'user': IUser;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new account
         * @summary Create a new account
         * @param {string} budgetId The id of the budget (\&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget)
         * @param {ISaveAccountWrapper} data The account to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (budgetId: string, data: ISaveAccountWrapper, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('createAccount', 'budgetId', budgetId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('createAccount', 'data', data)
            const localVarPath = `/budgets/{budget_id}/accounts`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single account
         * @summary Single account
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} accountId The id of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountById: async (budgetId: string, accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getAccountById', 'budgetId', budgetId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountById', 'accountId', accountId)
            const localVarPath = `/budgets/{budget_id}/accounts/{account_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all accounts
         * @summary Account list
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts: async (budgetId: string, lastKnowledgeOfServer?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getAccounts', 'budgetId', budgetId)
            const localVarPath = `/budgets/{budget_id}/accounts`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (lastKnowledgeOfServer !== undefined) {
                localVarQueryParameter['last_knowledge_of_server'] = lastKnowledgeOfServer;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new account
         * @summary Create a new account
         * @param {string} budgetId The id of the budget (\&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget)
         * @param {ISaveAccountWrapper} data The account to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(budgetId: string, data: ISaveAccountWrapper, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(budgetId, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single account
         * @summary Single account
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} accountId The id of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountById(budgetId: string, accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountById(budgetId, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all accounts
         * @summary Account list
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccounts(budgetId: string, lastKnowledgeOfServer?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IAccountsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccounts(budgetId, lastKnowledgeOfServer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Creates a new account
         * @summary Create a new account
         * @param {string} budgetId The id of the budget (\&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget)
         * @param {ISaveAccountWrapper} data The account to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(budgetId: string, data: ISaveAccountWrapper, options?: any): AxiosPromise<IAccountResponse> {
            return localVarFp.createAccount(budgetId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single account
         * @summary Single account
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} accountId The id of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountById(budgetId: string, accountId: string, options?: any): AxiosPromise<IAccountResponse> {
            return localVarFp.getAccountById(budgetId, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all accounts
         * @summary Account list
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(budgetId: string, lastKnowledgeOfServer?: number, options?: any): AxiosPromise<IAccountsResponse> {
            return localVarFp.getAccounts(budgetId, lastKnowledgeOfServer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Creates a new account
     * @summary Create a new account
     * @param {string} budgetId The id of the budget (\&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget)
     * @param {ISaveAccountWrapper} data The account to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public createAccount(budgetId: string, data: ISaveAccountWrapper, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).createAccount(budgetId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single account
     * @summary Single account
     * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
     * @param {string} accountId The id of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountById(budgetId: string, accountId: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccountById(budgetId, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all accounts
     * @summary Account list
     * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
     * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccounts(budgetId: string, lastKnowledgeOfServer?: number, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccounts(budgetId, lastKnowledgeOfServer, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BudgetsApi - axios parameter creator
 * @export
 */
export const BudgetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a single budget with all related entities.  This resource is effectively a full budget export.
         * @summary Single budget
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetById: async (budgetId: string, lastKnowledgeOfServer?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getBudgetById', 'budgetId', budgetId)
            const localVarPath = `/budgets/{budget_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (lastKnowledgeOfServer !== undefined) {
                localVarQueryParameter['last_knowledge_of_server'] = lastKnowledgeOfServer;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns settings for a budget
         * @summary Budget Settings
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetSettingsById: async (budgetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getBudgetSettingsById', 'budgetId', budgetId)
            const localVarPath = `/budgets/{budget_id}/settings`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns budgets list with summary information
         * @summary List budgets
         * @param {boolean} [includeAccounts] Whether to include the list of budget accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgets: async (includeAccounts?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/budgets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (includeAccounts !== undefined) {
                localVarQueryParameter['include_accounts'] = includeAccounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BudgetsApi - functional programming interface
 * @export
 */
export const BudgetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BudgetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a single budget with all related entities.  This resource is effectively a full budget export.
         * @summary Single budget
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBudgetById(budgetId: string, lastKnowledgeOfServer?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IBudgetDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBudgetById(budgetId, lastKnowledgeOfServer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns settings for a budget
         * @summary Budget Settings
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBudgetSettingsById(budgetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IBudgetSettingsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBudgetSettingsById(budgetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns budgets list with summary information
         * @summary List budgets
         * @param {boolean} [includeAccounts] Whether to include the list of budget accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBudgets(includeAccounts?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IBudgetSummaryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBudgets(includeAccounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BudgetsApi - factory interface
 * @export
 */
export const BudgetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BudgetsApiFp(configuration)
    return {
        /**
         * Returns a single budget with all related entities.  This resource is effectively a full budget export.
         * @summary Single budget
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetById(budgetId: string, lastKnowledgeOfServer?: number, options?: any): AxiosPromise<IBudgetDetailResponse> {
            return localVarFp.getBudgetById(budgetId, lastKnowledgeOfServer, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns settings for a budget
         * @summary Budget Settings
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetSettingsById(budgetId: string, options?: any): AxiosPromise<IBudgetSettingsResponse> {
            return localVarFp.getBudgetSettingsById(budgetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns budgets list with summary information
         * @summary List budgets
         * @param {boolean} [includeAccounts] Whether to include the list of budget accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgets(includeAccounts?: boolean, options?: any): AxiosPromise<IBudgetSummaryResponse> {
            return localVarFp.getBudgets(includeAccounts, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BudgetsApi - object-oriented interface
 * @export
 * @class BudgetsApi
 * @extends {BaseAPI}
 */
export class BudgetsApi extends BaseAPI {
    /**
     * Returns a single budget with all related entities.  This resource is effectively a full budget export.
     * @summary Single budget
     * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
     * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public getBudgetById(budgetId: string, lastKnowledgeOfServer?: number, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).getBudgetById(budgetId, lastKnowledgeOfServer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns settings for a budget
     * @summary Budget Settings
     * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public getBudgetSettingsById(budgetId: string, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).getBudgetSettingsById(budgetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns budgets list with summary information
     * @summary List budgets
     * @param {boolean} [includeAccounts] Whether to include the list of budget accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public getBudgets(includeAccounts?: boolean, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).getBudgets(includeAccounts, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CategoriesApi - axios parameter creator
 * @export
 */
export const CategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns all categories grouped by category group.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
         * @summary List categories
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories: async (budgetId: string, lastKnowledgeOfServer?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getCategories', 'budgetId', budgetId)
            const localVarPath = `/budgets/{budget_id}/categories`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (lastKnowledgeOfServer !== undefined) {
                localVarQueryParameter['last_knowledge_of_server'] = lastKnowledgeOfServer;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single category.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
         * @summary Single category
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} categoryId The id of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryById: async (budgetId: string, categoryId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getCategoryById', 'budgetId', budgetId)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getCategoryById', 'categoryId', categoryId)
            const localVarPath = `/budgets/{budget_id}/categories/{category_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single category for a specific budget month.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
         * @summary Single category for a specific budget month
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} month The budget month in ISO format (e.g. 2016-12-01) (\&quot;current\&quot; can also be used to specify the current calendar month (UTC))
         * @param {string} categoryId The id of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMonthCategoryById: async (budgetId: string, month: string, categoryId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getMonthCategoryById', 'budgetId', budgetId)
            // verify required parameter 'month' is not null or undefined
            assertParamExists('getMonthCategoryById', 'month', month)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getMonthCategoryById', 'categoryId', categoryId)
            const localVarPath = `/budgets/{budget_id}/months/{month}/categories/{category_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"month"}}`, encodeURIComponent(String(month)))
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a category for a specific month.  Only `budgeted` amount can be updated.
         * @summary Update a category for a specific month
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} month The budget month in ISO format (e.g. 2016-12-01) (\&quot;current\&quot; can also be used to specify the current calendar month (UTC))
         * @param {string} categoryId The id of the category
         * @param {ISaveMonthCategoryWrapper} data The category to update.  Only &#x60;budgeted&#x60; amount can be updated and any other fields specified will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMonthCategory: async (budgetId: string, month: string, categoryId: string, data: ISaveMonthCategoryWrapper, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('updateMonthCategory', 'budgetId', budgetId)
            // verify required parameter 'month' is not null or undefined
            assertParamExists('updateMonthCategory', 'month', month)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('updateMonthCategory', 'categoryId', categoryId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('updateMonthCategory', 'data', data)
            const localVarPath = `/budgets/{budget_id}/months/{month}/categories/{category_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"month"}}`, encodeURIComponent(String(month)))
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns all categories grouped by category group.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
         * @summary List categories
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategories(budgetId: string, lastKnowledgeOfServer?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ICategoriesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategories(budgetId, lastKnowledgeOfServer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single category.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
         * @summary Single category
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} categoryId The id of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoryById(budgetId: string, categoryId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ICategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoryById(budgetId, categoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single category for a specific budget month.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
         * @summary Single category for a specific budget month
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} month The budget month in ISO format (e.g. 2016-12-01) (\&quot;current\&quot; can also be used to specify the current calendar month (UTC))
         * @param {string} categoryId The id of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMonthCategoryById(budgetId: string, month: string, categoryId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ICategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMonthCategoryById(budgetId, month, categoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a category for a specific month.  Only `budgeted` amount can be updated.
         * @summary Update a category for a specific month
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} month The budget month in ISO format (e.g. 2016-12-01) (\&quot;current\&quot; can also be used to specify the current calendar month (UTC))
         * @param {string} categoryId The id of the category
         * @param {ISaveMonthCategoryWrapper} data The category to update.  Only &#x60;budgeted&#x60; amount can be updated and any other fields specified will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMonthCategory(budgetId: string, month: string, categoryId: string, data: ISaveMonthCategoryWrapper, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ISaveCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMonthCategory(budgetId, month, categoryId, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoriesApiFp(configuration)
    return {
        /**
         * Returns all categories grouped by category group.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
         * @summary List categories
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(budgetId: string, lastKnowledgeOfServer?: number, options?: any): AxiosPromise<ICategoriesResponse> {
            return localVarFp.getCategories(budgetId, lastKnowledgeOfServer, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single category.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
         * @summary Single category
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} categoryId The id of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryById(budgetId: string, categoryId: string, options?: any): AxiosPromise<ICategoryResponse> {
            return localVarFp.getCategoryById(budgetId, categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single category for a specific budget month.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
         * @summary Single category for a specific budget month
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} month The budget month in ISO format (e.g. 2016-12-01) (\&quot;current\&quot; can also be used to specify the current calendar month (UTC))
         * @param {string} categoryId The id of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMonthCategoryById(budgetId: string, month: string, categoryId: string, options?: any): AxiosPromise<ICategoryResponse> {
            return localVarFp.getMonthCategoryById(budgetId, month, categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a category for a specific month.  Only `budgeted` amount can be updated.
         * @summary Update a category for a specific month
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} month The budget month in ISO format (e.g. 2016-12-01) (\&quot;current\&quot; can also be used to specify the current calendar month (UTC))
         * @param {string} categoryId The id of the category
         * @param {ISaveMonthCategoryWrapper} data The category to update.  Only &#x60;budgeted&#x60; amount can be updated and any other fields specified will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMonthCategory(budgetId: string, month: string, categoryId: string, data: ISaveMonthCategoryWrapper, options?: any): AxiosPromise<ISaveCategoryResponse> {
            return localVarFp.updateMonthCategory(budgetId, month, categoryId, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
    /**
     * Returns all categories grouped by category group.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
     * @summary List categories
     * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
     * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public getCategories(budgetId: string, lastKnowledgeOfServer?: number, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).getCategories(budgetId, lastKnowledgeOfServer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single category.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
     * @summary Single category
     * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
     * @param {string} categoryId The id of the category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public getCategoryById(budgetId: string, categoryId: string, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).getCategoryById(budgetId, categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single category for a specific budget month.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
     * @summary Single category for a specific budget month
     * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
     * @param {string} month The budget month in ISO format (e.g. 2016-12-01) (\&quot;current\&quot; can also be used to specify the current calendar month (UTC))
     * @param {string} categoryId The id of the category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public getMonthCategoryById(budgetId: string, month: string, categoryId: string, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).getMonthCategoryById(budgetId, month, categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a category for a specific month.  Only `budgeted` amount can be updated.
     * @summary Update a category for a specific month
     * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
     * @param {string} month The budget month in ISO format (e.g. 2016-12-01) (\&quot;current\&quot; can also be used to specify the current calendar month (UTC))
     * @param {string} categoryId The id of the category
     * @param {ISaveMonthCategoryWrapper} data The category to update.  Only &#x60;budgeted&#x60; amount can be updated and any other fields specified will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public updateMonthCategory(budgetId: string, month: string, categoryId: string, data: ISaveMonthCategoryWrapper, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).updateMonthCategory(budgetId, month, categoryId, data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeprecatedApi - axios parameter creator
 * @export
 */
export const DeprecatedApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates multiple transactions.  Although this endpoint is still supported, it is recommended to use \'POST /budgets/{budget_id}/transactions\' to create multiple transactions.
         * @summary Bulk create transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {IBulkTransactions} transactions The list of transactions to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateTransactions: async (budgetId: string, transactions: IBulkTransactions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('bulkCreateTransactions', 'budgetId', budgetId)
            // verify required parameter 'transactions' is not null or undefined
            assertParamExists('bulkCreateTransactions', 'transactions', transactions)
            const localVarPath = `/budgets/{budget_id}/transactions/bulk`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeprecatedApi - functional programming interface
 * @export
 */
export const DeprecatedApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeprecatedApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates multiple transactions.  Although this endpoint is still supported, it is recommended to use \'POST /budgets/{budget_id}/transactions\' to create multiple transactions.
         * @summary Bulk create transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {IBulkTransactions} transactions The list of transactions to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkCreateTransactions(budgetId: string, transactions: IBulkTransactions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IBulkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkCreateTransactions(budgetId, transactions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeprecatedApi - factory interface
 * @export
 */
export const DeprecatedApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeprecatedApiFp(configuration)
    return {
        /**
         * Creates multiple transactions.  Although this endpoint is still supported, it is recommended to use \'POST /budgets/{budget_id}/transactions\' to create multiple transactions.
         * @summary Bulk create transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {IBulkTransactions} transactions The list of transactions to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateTransactions(budgetId: string, transactions: IBulkTransactions, options?: any): AxiosPromise<IBulkResponse> {
            return localVarFp.bulkCreateTransactions(budgetId, transactions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeprecatedApi - object-oriented interface
 * @export
 * @class DeprecatedApi
 * @extends {BaseAPI}
 */
export class DeprecatedApi extends BaseAPI {
    /**
     * Creates multiple transactions.  Although this endpoint is still supported, it is recommended to use \'POST /budgets/{budget_id}/transactions\' to create multiple transactions.
     * @summary Bulk create transactions
     * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
     * @param {IBulkTransactions} transactions The list of transactions to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeprecatedApi
     */
    public bulkCreateTransactions(budgetId: string, transactions: IBulkTransactions, options?: AxiosRequestConfig) {
        return DeprecatedApiFp(this.configuration).bulkCreateTransactions(budgetId, transactions, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MonthsApi - axios parameter creator
 * @export
 */
export const MonthsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a single budget month
         * @summary Single budget month
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} month The budget month in ISO format (e.g. 2016-12-01) (\&quot;current\&quot; can also be used to specify the current calendar month (UTC))
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetMonth: async (budgetId: string, month: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getBudgetMonth', 'budgetId', budgetId)
            // verify required parameter 'month' is not null or undefined
            assertParamExists('getBudgetMonth', 'month', month)
            const localVarPath = `/budgets/{budget_id}/months/{month}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"month"}}`, encodeURIComponent(String(month)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all budget months
         * @summary List budget months
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetMonths: async (budgetId: string, lastKnowledgeOfServer?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getBudgetMonths', 'budgetId', budgetId)
            const localVarPath = `/budgets/{budget_id}/months`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (lastKnowledgeOfServer !== undefined) {
                localVarQueryParameter['last_knowledge_of_server'] = lastKnowledgeOfServer;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MonthsApi - functional programming interface
 * @export
 */
export const MonthsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MonthsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a single budget month
         * @summary Single budget month
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} month The budget month in ISO format (e.g. 2016-12-01) (\&quot;current\&quot; can also be used to specify the current calendar month (UTC))
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBudgetMonth(budgetId: string, month: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IMonthDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBudgetMonth(budgetId, month, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all budget months
         * @summary List budget months
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBudgetMonths(budgetId: string, lastKnowledgeOfServer?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IMonthSummariesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBudgetMonths(budgetId, lastKnowledgeOfServer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MonthsApi - factory interface
 * @export
 */
export const MonthsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MonthsApiFp(configuration)
    return {
        /**
         * Returns a single budget month
         * @summary Single budget month
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} month The budget month in ISO format (e.g. 2016-12-01) (\&quot;current\&quot; can also be used to specify the current calendar month (UTC))
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetMonth(budgetId: string, month: string, options?: any): AxiosPromise<IMonthDetailResponse> {
            return localVarFp.getBudgetMonth(budgetId, month, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all budget months
         * @summary List budget months
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetMonths(budgetId: string, lastKnowledgeOfServer?: number, options?: any): AxiosPromise<IMonthSummariesResponse> {
            return localVarFp.getBudgetMonths(budgetId, lastKnowledgeOfServer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MonthsApi - object-oriented interface
 * @export
 * @class MonthsApi
 * @extends {BaseAPI}
 */
export class MonthsApi extends BaseAPI {
    /**
     * Returns a single budget month
     * @summary Single budget month
     * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
     * @param {string} month The budget month in ISO format (e.g. 2016-12-01) (\&quot;current\&quot; can also be used to specify the current calendar month (UTC))
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonthsApi
     */
    public getBudgetMonth(budgetId: string, month: string, options?: AxiosRequestConfig) {
        return MonthsApiFp(this.configuration).getBudgetMonth(budgetId, month, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all budget months
     * @summary List budget months
     * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
     * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonthsApi
     */
    public getBudgetMonths(budgetId: string, lastKnowledgeOfServer?: number, options?: AxiosRequestConfig) {
        return MonthsApiFp(this.configuration).getBudgetMonths(budgetId, lastKnowledgeOfServer, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PayeeLocationsApi - axios parameter creator
 * @export
 */
export const PayeeLocationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a single payee location
         * @summary Single payee location
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} payeeLocationId id of payee location
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayeeLocationById: async (budgetId: string, payeeLocationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getPayeeLocationById', 'budgetId', budgetId)
            // verify required parameter 'payeeLocationId' is not null or undefined
            assertParamExists('getPayeeLocationById', 'payeeLocationId', payeeLocationId)
            const localVarPath = `/budgets/{budget_id}/payee_locations/{payee_location_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"payee_location_id"}}`, encodeURIComponent(String(payeeLocationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all payee locations
         * @summary List payee locations
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayeeLocations: async (budgetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getPayeeLocations', 'budgetId', budgetId)
            const localVarPath = `/budgets/{budget_id}/payee_locations`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all payee locations for a specified payee
         * @summary List locations for a payee
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} payeeId id of payee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayeeLocationsByPayee: async (budgetId: string, payeeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getPayeeLocationsByPayee', 'budgetId', budgetId)
            // verify required parameter 'payeeId' is not null or undefined
            assertParamExists('getPayeeLocationsByPayee', 'payeeId', payeeId)
            const localVarPath = `/budgets/{budget_id}/payees/{payee_id}/payee_locations`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"payee_id"}}`, encodeURIComponent(String(payeeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PayeeLocationsApi - functional programming interface
 * @export
 */
export const PayeeLocationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PayeeLocationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a single payee location
         * @summary Single payee location
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} payeeLocationId id of payee location
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayeeLocationById(budgetId: string, payeeLocationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IPayeeLocationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayeeLocationById(budgetId, payeeLocationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all payee locations
         * @summary List payee locations
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayeeLocations(budgetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IPayeeLocationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayeeLocations(budgetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all payee locations for a specified payee
         * @summary List locations for a payee
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} payeeId id of payee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayeeLocationsByPayee(budgetId: string, payeeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IPayeeLocationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayeeLocationsByPayee(budgetId, payeeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PayeeLocationsApi - factory interface
 * @export
 */
export const PayeeLocationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PayeeLocationsApiFp(configuration)
    return {
        /**
         * Returns a single payee location
         * @summary Single payee location
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} payeeLocationId id of payee location
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayeeLocationById(budgetId: string, payeeLocationId: string, options?: any): AxiosPromise<IPayeeLocationResponse> {
            return localVarFp.getPayeeLocationById(budgetId, payeeLocationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all payee locations
         * @summary List payee locations
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayeeLocations(budgetId: string, options?: any): AxiosPromise<IPayeeLocationsResponse> {
            return localVarFp.getPayeeLocations(budgetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all payee locations for a specified payee
         * @summary List locations for a payee
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} payeeId id of payee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayeeLocationsByPayee(budgetId: string, payeeId: string, options?: any): AxiosPromise<IPayeeLocationsResponse> {
            return localVarFp.getPayeeLocationsByPayee(budgetId, payeeId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PayeeLocationsApi - object-oriented interface
 * @export
 * @class PayeeLocationsApi
 * @extends {BaseAPI}
 */
export class PayeeLocationsApi extends BaseAPI {
    /**
     * Returns a single payee location
     * @summary Single payee location
     * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
     * @param {string} payeeLocationId id of payee location
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayeeLocationsApi
     */
    public getPayeeLocationById(budgetId: string, payeeLocationId: string, options?: AxiosRequestConfig) {
        return PayeeLocationsApiFp(this.configuration).getPayeeLocationById(budgetId, payeeLocationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all payee locations
     * @summary List payee locations
     * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayeeLocationsApi
     */
    public getPayeeLocations(budgetId: string, options?: AxiosRequestConfig) {
        return PayeeLocationsApiFp(this.configuration).getPayeeLocations(budgetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all payee locations for a specified payee
     * @summary List locations for a payee
     * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
     * @param {string} payeeId id of payee
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayeeLocationsApi
     */
    public getPayeeLocationsByPayee(budgetId: string, payeeId: string, options?: AxiosRequestConfig) {
        return PayeeLocationsApiFp(this.configuration).getPayeeLocationsByPayee(budgetId, payeeId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PayeesApi - axios parameter creator
 * @export
 */
export const PayeesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a single payee
         * @summary Single payee
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} payeeId The id of the payee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayeeById: async (budgetId: string, payeeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getPayeeById', 'budgetId', budgetId)
            // verify required parameter 'payeeId' is not null or undefined
            assertParamExists('getPayeeById', 'payeeId', payeeId)
            const localVarPath = `/budgets/{budget_id}/payees/{payee_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"payee_id"}}`, encodeURIComponent(String(payeeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all payees
         * @summary List payees
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayees: async (budgetId: string, lastKnowledgeOfServer?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getPayees', 'budgetId', budgetId)
            const localVarPath = `/budgets/{budget_id}/payees`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (lastKnowledgeOfServer !== undefined) {
                localVarQueryParameter['last_knowledge_of_server'] = lastKnowledgeOfServer;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PayeesApi - functional programming interface
 * @export
 */
export const PayeesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PayeesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a single payee
         * @summary Single payee
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} payeeId The id of the payee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayeeById(budgetId: string, payeeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IPayeeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayeeById(budgetId, payeeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all payees
         * @summary List payees
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayees(budgetId: string, lastKnowledgeOfServer?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IPayeesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayees(budgetId, lastKnowledgeOfServer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PayeesApi - factory interface
 * @export
 */
export const PayeesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PayeesApiFp(configuration)
    return {
        /**
         * Returns a single payee
         * @summary Single payee
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} payeeId The id of the payee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayeeById(budgetId: string, payeeId: string, options?: any): AxiosPromise<IPayeeResponse> {
            return localVarFp.getPayeeById(budgetId, payeeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all payees
         * @summary List payees
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayees(budgetId: string, lastKnowledgeOfServer?: number, options?: any): AxiosPromise<IPayeesResponse> {
            return localVarFp.getPayees(budgetId, lastKnowledgeOfServer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PayeesApi - object-oriented interface
 * @export
 * @class PayeesApi
 * @extends {BaseAPI}
 */
export class PayeesApi extends BaseAPI {
    /**
     * Returns a single payee
     * @summary Single payee
     * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
     * @param {string} payeeId The id of the payee
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayeesApi
     */
    public getPayeeById(budgetId: string, payeeId: string, options?: AxiosRequestConfig) {
        return PayeesApiFp(this.configuration).getPayeeById(budgetId, payeeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all payees
     * @summary List payees
     * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
     * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayeesApi
     */
    public getPayees(budgetId: string, lastKnowledgeOfServer?: number, options?: AxiosRequestConfig) {
        return PayeesApiFp(this.configuration).getPayees(budgetId, lastKnowledgeOfServer, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ScheduledTransactionsApi - axios parameter creator
 * @export
 */
export const ScheduledTransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a single scheduled transaction
         * @summary Single scheduled transaction
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} scheduledTransactionId The id of the scheduled transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduledTransactionById: async (budgetId: string, scheduledTransactionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getScheduledTransactionById', 'budgetId', budgetId)
            // verify required parameter 'scheduledTransactionId' is not null or undefined
            assertParamExists('getScheduledTransactionById', 'scheduledTransactionId', scheduledTransactionId)
            const localVarPath = `/budgets/{budget_id}/scheduled_transactions/{scheduled_transaction_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"scheduled_transaction_id"}}`, encodeURIComponent(String(scheduledTransactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all scheduled transactions
         * @summary List scheduled transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduledTransactions: async (budgetId: string, lastKnowledgeOfServer?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getScheduledTransactions', 'budgetId', budgetId)
            const localVarPath = `/budgets/{budget_id}/scheduled_transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (lastKnowledgeOfServer !== undefined) {
                localVarQueryParameter['last_knowledge_of_server'] = lastKnowledgeOfServer;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScheduledTransactionsApi - functional programming interface
 * @export
 */
export const ScheduledTransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScheduledTransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a single scheduled transaction
         * @summary Single scheduled transaction
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} scheduledTransactionId The id of the scheduled transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScheduledTransactionById(budgetId: string, scheduledTransactionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IScheduledTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScheduledTransactionById(budgetId, scheduledTransactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all scheduled transactions
         * @summary List scheduled transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScheduledTransactions(budgetId: string, lastKnowledgeOfServer?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IScheduledTransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScheduledTransactions(budgetId, lastKnowledgeOfServer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ScheduledTransactionsApi - factory interface
 * @export
 */
export const ScheduledTransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScheduledTransactionsApiFp(configuration)
    return {
        /**
         * Returns a single scheduled transaction
         * @summary Single scheduled transaction
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} scheduledTransactionId The id of the scheduled transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduledTransactionById(budgetId: string, scheduledTransactionId: string, options?: any): AxiosPromise<IScheduledTransactionResponse> {
            return localVarFp.getScheduledTransactionById(budgetId, scheduledTransactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all scheduled transactions
         * @summary List scheduled transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduledTransactions(budgetId: string, lastKnowledgeOfServer?: number, options?: any): AxiosPromise<IScheduledTransactionsResponse> {
            return localVarFp.getScheduledTransactions(budgetId, lastKnowledgeOfServer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScheduledTransactionsApi - object-oriented interface
 * @export
 * @class ScheduledTransactionsApi
 * @extends {BaseAPI}
 */
export class ScheduledTransactionsApi extends BaseAPI {
    /**
     * Returns a single scheduled transaction
     * @summary Single scheduled transaction
     * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
     * @param {string} scheduledTransactionId The id of the scheduled transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledTransactionsApi
     */
    public getScheduledTransactionById(budgetId: string, scheduledTransactionId: string, options?: AxiosRequestConfig) {
        return ScheduledTransactionsApiFp(this.configuration).getScheduledTransactionById(budgetId, scheduledTransactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all scheduled transactions
     * @summary List scheduled transactions
     * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
     * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledTransactionsApi
     */
    public getScheduledTransactions(budgetId: string, lastKnowledgeOfServer?: number, options?: AxiosRequestConfig) {
        return ScheduledTransactionsApiFp(this.configuration).getScheduledTransactions(budgetId, lastKnowledgeOfServer, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a single transaction or multiple transactions.  If you provide a body containing a `transaction` object, a single transaction will be created and if you provide a body containing a `transactions` array, multiple transactions will be created.  Scheduled transactions cannot be created on this endpoint.
         * @summary Create a single transaction or multiple transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {ISaveTransactionsWrapper} data The transaction or transactions to create.  To create a single transaction you can specify a value for the &#x60;transaction&#x60; object and to create multiple transactions you can specify an array of &#x60;transactions&#x60;.  It is expected that you will only provide a value for one of these objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction: async (budgetId: string, data: ISaveTransactionsWrapper, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('createTransaction', 'budgetId', budgetId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('createTransaction', 'data', data)
            const localVarPath = `/budgets/{budget_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single transaction
         * @summary Single transaction
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} transactionId The id of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionById: async (budgetId: string, transactionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getTransactionById', 'budgetId', budgetId)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getTransactionById', 'transactionId', transactionId)
            const localVarPath = `/budgets/{budget_id}/transactions/{transaction_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns budget transactions
         * @summary List transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} [sinceDate] If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
         * @param {'uncategorized' | 'unapproved'} [type] If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported.
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions: async (budgetId: string, sinceDate?: string, type?: 'uncategorized' | 'unapproved', lastKnowledgeOfServer?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getTransactions', 'budgetId', budgetId)
            const localVarPath = `/budgets/{budget_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (sinceDate !== undefined) {
                localVarQueryParameter['since_date'] = (sinceDate as any instanceof Date) ?
                    (sinceDate as any).toISOString().substr(0,10) :
                    sinceDate;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (lastKnowledgeOfServer !== undefined) {
                localVarQueryParameter['last_knowledge_of_server'] = lastKnowledgeOfServer;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transactions for a specified account
         * @summary List account transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} accountId The id of the account
         * @param {string} [sinceDate] If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
         * @param {'uncategorized' | 'unapproved'} [type] If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported.
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsByAccount: async (budgetId: string, accountId: string, sinceDate?: string, type?: 'uncategorized' | 'unapproved', lastKnowledgeOfServer?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getTransactionsByAccount', 'budgetId', budgetId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getTransactionsByAccount', 'accountId', accountId)
            const localVarPath = `/budgets/{budget_id}/accounts/{account_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (sinceDate !== undefined) {
                localVarQueryParameter['since_date'] = (sinceDate as any instanceof Date) ?
                    (sinceDate as any).toISOString().substr(0,10) :
                    sinceDate;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (lastKnowledgeOfServer !== undefined) {
                localVarQueryParameter['last_knowledge_of_server'] = lastKnowledgeOfServer;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transactions for a specified category
         * @summary List category transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} categoryId The id of the category
         * @param {string} [sinceDate] If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
         * @param {'uncategorized' | 'unapproved'} [type] If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported.
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsByCategory: async (budgetId: string, categoryId: string, sinceDate?: string, type?: 'uncategorized' | 'unapproved', lastKnowledgeOfServer?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getTransactionsByCategory', 'budgetId', budgetId)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getTransactionsByCategory', 'categoryId', categoryId)
            const localVarPath = `/budgets/{budget_id}/categories/{category_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (sinceDate !== undefined) {
                localVarQueryParameter['since_date'] = (sinceDate as any instanceof Date) ?
                    (sinceDate as any).toISOString().substr(0,10) :
                    sinceDate;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (lastKnowledgeOfServer !== undefined) {
                localVarQueryParameter['last_knowledge_of_server'] = lastKnowledgeOfServer;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transactions for a specified payee
         * @summary List payee transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} payeeId The id of the payee
         * @param {string} [sinceDate] If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
         * @param {'uncategorized' | 'unapproved'} [type] If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported.
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsByPayee: async (budgetId: string, payeeId: string, sinceDate?: string, type?: 'uncategorized' | 'unapproved', lastKnowledgeOfServer?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getTransactionsByPayee', 'budgetId', budgetId)
            // verify required parameter 'payeeId' is not null or undefined
            assertParamExists('getTransactionsByPayee', 'payeeId', payeeId)
            const localVarPath = `/budgets/{budget_id}/payees/{payee_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"payee_id"}}`, encodeURIComponent(String(payeeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (sinceDate !== undefined) {
                localVarQueryParameter['since_date'] = (sinceDate as any instanceof Date) ?
                    (sinceDate as any).toISOString().substr(0,10) :
                    sinceDate;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (lastKnowledgeOfServer !== undefined) {
                localVarQueryParameter['last_knowledge_of_server'] = lastKnowledgeOfServer;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Imports available transactions on all linked accounts for the given budget.  Linked accounts allow transactions to be imported directly from a specified financial institution and this endpoint initiates that import.  Sending a request to this endpoint is the equivalent of clicking \"Import\" on each account in the web application or tapping the \"New Transactions\" banner in the mobile applications.  The response for this endpoint contains the transaction ids that have been imported.
         * @summary Import transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importTransactions: async (budgetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('importTransactions', 'budgetId', budgetId)
            const localVarPath = `/budgets/{budget_id}/transactions/import`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a single transaction
         * @summary Updates an existing transaction
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} transactionId The id of the transaction
         * @param {ISaveTransactionWrapper} data The transaction to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction: async (budgetId: string, transactionId: string, data: ISaveTransactionWrapper, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('updateTransaction', 'budgetId', budgetId)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('updateTransaction', 'transactionId', transactionId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('updateTransaction', 'data', data)
            const localVarPath = `/budgets/{budget_id}/transactions/{transaction_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)))
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates multiple transactions, by `id` or `import_id`.
         * @summary Update multiple transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {IUpdateTransactionsWrapper} data The transactions to update. Each transaction must have either an &#x60;id&#x60; or &#x60;import_id&#x60; specified. If &#x60;id&#x60; is specified as null an &#x60;import_id&#x60; value can be provided which will allow transaction(s) to be updated by their &#x60;import_id&#x60;. If an &#x60;id&#x60; is specified, it will always be used for lookup.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactions: async (budgetId: string, data: IUpdateTransactionsWrapper, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('updateTransactions', 'budgetId', budgetId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('updateTransactions', 'data', data)
            const localVarPath = `/budgets/{budget_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budgetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a single transaction or multiple transactions.  If you provide a body containing a `transaction` object, a single transaction will be created and if you provide a body containing a `transactions` array, multiple transactions will be created.  Scheduled transactions cannot be created on this endpoint.
         * @summary Create a single transaction or multiple transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {ISaveTransactionsWrapper} data The transaction or transactions to create.  To create a single transaction you can specify a value for the &#x60;transaction&#x60; object and to create multiple transactions you can specify an array of &#x60;transactions&#x60;.  It is expected that you will only provide a value for one of these objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransaction(budgetId: string, data: ISaveTransactionsWrapper, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ISaveTransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransaction(budgetId, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single transaction
         * @summary Single transaction
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} transactionId The id of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionById(budgetId: string, transactionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ITransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionById(budgetId, transactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns budget transactions
         * @summary List transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} [sinceDate] If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
         * @param {'uncategorized' | 'unapproved'} [type] If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported.
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactions(budgetId: string, sinceDate?: string, type?: 'uncategorized' | 'unapproved', lastKnowledgeOfServer?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ITransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactions(budgetId, sinceDate, type, lastKnowledgeOfServer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all transactions for a specified account
         * @summary List account transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} accountId The id of the account
         * @param {string} [sinceDate] If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
         * @param {'uncategorized' | 'unapproved'} [type] If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported.
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionsByAccount(budgetId: string, accountId: string, sinceDate?: string, type?: 'uncategorized' | 'unapproved', lastKnowledgeOfServer?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ITransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionsByAccount(budgetId, accountId, sinceDate, type, lastKnowledgeOfServer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all transactions for a specified category
         * @summary List category transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} categoryId The id of the category
         * @param {string} [sinceDate] If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
         * @param {'uncategorized' | 'unapproved'} [type] If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported.
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionsByCategory(budgetId: string, categoryId: string, sinceDate?: string, type?: 'uncategorized' | 'unapproved', lastKnowledgeOfServer?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IHybridTransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionsByCategory(budgetId, categoryId, sinceDate, type, lastKnowledgeOfServer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all transactions for a specified payee
         * @summary List payee transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} payeeId The id of the payee
         * @param {string} [sinceDate] If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
         * @param {'uncategorized' | 'unapproved'} [type] If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported.
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionsByPayee(budgetId: string, payeeId: string, sinceDate?: string, type?: 'uncategorized' | 'unapproved', lastKnowledgeOfServer?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IHybridTransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionsByPayee(budgetId, payeeId, sinceDate, type, lastKnowledgeOfServer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Imports available transactions on all linked accounts for the given budget.  Linked accounts allow transactions to be imported directly from a specified financial institution and this endpoint initiates that import.  Sending a request to this endpoint is the equivalent of clicking \"Import\" on each account in the web application or tapping the \"New Transactions\" banner in the mobile applications.  The response for this endpoint contains the transaction ids that have been imported.
         * @summary Import transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importTransactions(budgetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ITransactionsImportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importTransactions(budgetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a single transaction
         * @summary Updates an existing transaction
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} transactionId The id of the transaction
         * @param {ISaveTransactionWrapper} data The transaction to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTransaction(budgetId: string, transactionId: string, data: ISaveTransactionWrapper, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ITransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTransaction(budgetId, transactionId, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates multiple transactions, by `id` or `import_id`.
         * @summary Update multiple transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {IUpdateTransactionsWrapper} data The transactions to update. Each transaction must have either an &#x60;id&#x60; or &#x60;import_id&#x60; specified. If &#x60;id&#x60; is specified as null an &#x60;import_id&#x60; value can be provided which will allow transaction(s) to be updated by their &#x60;import_id&#x60;. If an &#x60;id&#x60; is specified, it will always be used for lookup.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTransactions(budgetId: string, data: IUpdateTransactionsWrapper, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ISaveTransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTransactions(budgetId, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * Creates a single transaction or multiple transactions.  If you provide a body containing a `transaction` object, a single transaction will be created and if you provide a body containing a `transactions` array, multiple transactions will be created.  Scheduled transactions cannot be created on this endpoint.
         * @summary Create a single transaction or multiple transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {ISaveTransactionsWrapper} data The transaction or transactions to create.  To create a single transaction you can specify a value for the &#x60;transaction&#x60; object and to create multiple transactions you can specify an array of &#x60;transactions&#x60;.  It is expected that you will only provide a value for one of these objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction(budgetId: string, data: ISaveTransactionsWrapper, options?: any): AxiosPromise<ISaveTransactionsResponse> {
            return localVarFp.createTransaction(budgetId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single transaction
         * @summary Single transaction
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} transactionId The id of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionById(budgetId: string, transactionId: string, options?: any): AxiosPromise<ITransactionResponse> {
            return localVarFp.getTransactionById(budgetId, transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns budget transactions
         * @summary List transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} [sinceDate] If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
         * @param {'uncategorized' | 'unapproved'} [type] If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported.
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions(budgetId: string, sinceDate?: string, type?: 'uncategorized' | 'unapproved', lastKnowledgeOfServer?: number, options?: any): AxiosPromise<ITransactionsResponse> {
            return localVarFp.getTransactions(budgetId, sinceDate, type, lastKnowledgeOfServer, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all transactions for a specified account
         * @summary List account transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} accountId The id of the account
         * @param {string} [sinceDate] If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
         * @param {'uncategorized' | 'unapproved'} [type] If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported.
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsByAccount(budgetId: string, accountId: string, sinceDate?: string, type?: 'uncategorized' | 'unapproved', lastKnowledgeOfServer?: number, options?: any): AxiosPromise<ITransactionsResponse> {
            return localVarFp.getTransactionsByAccount(budgetId, accountId, sinceDate, type, lastKnowledgeOfServer, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all transactions for a specified category
         * @summary List category transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} categoryId The id of the category
         * @param {string} [sinceDate] If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
         * @param {'uncategorized' | 'unapproved'} [type] If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported.
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsByCategory(budgetId: string, categoryId: string, sinceDate?: string, type?: 'uncategorized' | 'unapproved', lastKnowledgeOfServer?: number, options?: any): AxiosPromise<IHybridTransactionsResponse> {
            return localVarFp.getTransactionsByCategory(budgetId, categoryId, sinceDate, type, lastKnowledgeOfServer, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all transactions for a specified payee
         * @summary List payee transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} payeeId The id of the payee
         * @param {string} [sinceDate] If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
         * @param {'uncategorized' | 'unapproved'} [type] If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported.
         * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsByPayee(budgetId: string, payeeId: string, sinceDate?: string, type?: 'uncategorized' | 'unapproved', lastKnowledgeOfServer?: number, options?: any): AxiosPromise<IHybridTransactionsResponse> {
            return localVarFp.getTransactionsByPayee(budgetId, payeeId, sinceDate, type, lastKnowledgeOfServer, options).then((request) => request(axios, basePath));
        },
        /**
         * Imports available transactions on all linked accounts for the given budget.  Linked accounts allow transactions to be imported directly from a specified financial institution and this endpoint initiates that import.  Sending a request to this endpoint is the equivalent of clicking \"Import\" on each account in the web application or tapping the \"New Transactions\" banner in the mobile applications.  The response for this endpoint contains the transaction ids that have been imported.
         * @summary Import transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importTransactions(budgetId: string, options?: any): AxiosPromise<ITransactionsImportResponse> {
            return localVarFp.importTransactions(budgetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a single transaction
         * @summary Updates an existing transaction
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {string} transactionId The id of the transaction
         * @param {ISaveTransactionWrapper} data The transaction to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction(budgetId: string, transactionId: string, data: ISaveTransactionWrapper, options?: any): AxiosPromise<ITransactionResponse> {
            return localVarFp.updateTransaction(budgetId, transactionId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates multiple transactions, by `id` or `import_id`.
         * @summary Update multiple transactions
         * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
         * @param {IUpdateTransactionsWrapper} data The transactions to update. Each transaction must have either an &#x60;id&#x60; or &#x60;import_id&#x60; specified. If &#x60;id&#x60; is specified as null an &#x60;import_id&#x60; value can be provided which will allow transaction(s) to be updated by their &#x60;import_id&#x60;. If an &#x60;id&#x60; is specified, it will always be used for lookup.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactions(budgetId: string, data: IUpdateTransactionsWrapper, options?: any): AxiosPromise<ISaveTransactionsResponse> {
            return localVarFp.updateTransactions(budgetId, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * Creates a single transaction or multiple transactions.  If you provide a body containing a `transaction` object, a single transaction will be created and if you provide a body containing a `transactions` array, multiple transactions will be created.  Scheduled transactions cannot be created on this endpoint.
     * @summary Create a single transaction or multiple transactions
     * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
     * @param {ISaveTransactionsWrapper} data The transaction or transactions to create.  To create a single transaction you can specify a value for the &#x60;transaction&#x60; object and to create multiple transactions you can specify an array of &#x60;transactions&#x60;.  It is expected that you will only provide a value for one of these objects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public createTransaction(budgetId: string, data: ISaveTransactionsWrapper, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).createTransaction(budgetId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single transaction
     * @summary Single transaction
     * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
     * @param {string} transactionId The id of the transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionById(budgetId: string, transactionId: string, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getTransactionById(budgetId, transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns budget transactions
     * @summary List transactions
     * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
     * @param {string} [sinceDate] If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
     * @param {'uncategorized' | 'unapproved'} [type] If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported.
     * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactions(budgetId: string, sinceDate?: string, type?: 'uncategorized' | 'unapproved', lastKnowledgeOfServer?: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getTransactions(budgetId, sinceDate, type, lastKnowledgeOfServer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all transactions for a specified account
     * @summary List account transactions
     * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
     * @param {string} accountId The id of the account
     * @param {string} [sinceDate] If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
     * @param {'uncategorized' | 'unapproved'} [type] If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported.
     * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionsByAccount(budgetId: string, accountId: string, sinceDate?: string, type?: 'uncategorized' | 'unapproved', lastKnowledgeOfServer?: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getTransactionsByAccount(budgetId, accountId, sinceDate, type, lastKnowledgeOfServer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all transactions for a specified category
     * @summary List category transactions
     * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
     * @param {string} categoryId The id of the category
     * @param {string} [sinceDate] If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
     * @param {'uncategorized' | 'unapproved'} [type] If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported.
     * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionsByCategory(budgetId: string, categoryId: string, sinceDate?: string, type?: 'uncategorized' | 'unapproved', lastKnowledgeOfServer?: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getTransactionsByCategory(budgetId, categoryId, sinceDate, type, lastKnowledgeOfServer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all transactions for a specified payee
     * @summary List payee transactions
     * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
     * @param {string} payeeId The id of the payee
     * @param {string} [sinceDate] If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
     * @param {'uncategorized' | 'unapproved'} [type] If specified, only transactions of the specified type will be included. \&quot;uncategorized\&quot; and \&quot;unapproved\&quot; are currently supported.
     * @param {number} [lastKnowledgeOfServer] The starting server knowledge.  If provided, only entities that have changed since &#x60;last_knowledge_of_server&#x60; will be included.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionsByPayee(budgetId: string, payeeId: string, sinceDate?: string, type?: 'uncategorized' | 'unapproved', lastKnowledgeOfServer?: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getTransactionsByPayee(budgetId, payeeId, sinceDate, type, lastKnowledgeOfServer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Imports available transactions on all linked accounts for the given budget.  Linked accounts allow transactions to be imported directly from a specified financial institution and this endpoint initiates that import.  Sending a request to this endpoint is the equivalent of clicking \"Import\" on each account in the web application or tapping the \"New Transactions\" banner in the mobile applications.  The response for this endpoint contains the transaction ids that have been imported.
     * @summary Import transactions
     * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public importTransactions(budgetId: string, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).importTransactions(budgetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a single transaction
     * @summary Updates an existing transaction
     * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
     * @param {string} transactionId The id of the transaction
     * @param {ISaveTransactionWrapper} data The transaction to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public updateTransaction(budgetId: string, transactionId: string, data: ISaveTransactionWrapper, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).updateTransaction(budgetId, transactionId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates multiple transactions, by `id` or `import_id`.
     * @summary Update multiple transactions
     * @param {string} budgetId The id of the budget. \&quot;last-used\&quot; can be used to specify the last used budget and \&quot;default\&quot; can be used if default budget selection is enabled (see: https://api.youneedabudget.com/#oauth-default-budget).
     * @param {IUpdateTransactionsWrapper} data The transactions to update. Each transaction must have either an &#x60;id&#x60; or &#x60;import_id&#x60; specified. If &#x60;id&#x60; is specified as null an &#x60;import_id&#x60; value can be provided which will allow transaction(s) to be updated by their &#x60;import_id&#x60;. If an &#x60;id&#x60; is specified, it will always be used for lookup.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public updateTransactions(budgetId: string, data: IUpdateTransactionsWrapper, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).updateTransactions(budgetId, data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns authenticated user information
         * @summary User info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns authenticated user information
         * @summary User info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Returns authenticated user information
         * @summary User info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any): AxiosPromise<IUserResponse> {
            return localVarFp.getUser(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Returns authenticated user information
     * @summary User info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser(options).then((request) => request(this.axios, this.basePath));
    }
}


